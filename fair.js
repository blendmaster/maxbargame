// Generated by LiveScript 1.2.0
var height, width, sections, handleHeight, body, x$, svg, wants, paths, limits, y$, handles, handleTop, handleBot, Player, players, bandwidth, byNeeded, allocs, stackAllocs, reallocate, yScale, totalWanted, totalLimited, scaleHeight, wantedPadding, limitedPadding, stackWanted, stackLimited, rescale, drag, curve, drawSchematic;
height = 400;
width = 500;
sections = [0, width / 5, 2 * width / 5, 3 * width / 5, 4 * width / 5, 5 * width / 5];
handleHeight = 10;
body = d3.select(document.body);
x$ = svg = d3.select('#svg').attr({
  width: width,
  height: height
});
wants = x$.append('g').attr('id', 'wants');
paths = x$.append('g').attr('id', 'paths');
limits = x$.append('g').attr('id', 'limits');
y$ = handles = x$.append('g').attr('id', 'handles');
handleTop = y$.append('rect').attr({
  id: 'handle-top',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
handleBot = y$.append('rect').attr({
  id: 'handle-bot',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  function Player(id, wanted, limited){
    this.id = id;
    this.wanted = wanted;
    this.limited = limited;
    this.needed = Math.min(this.wanted, this.limited);
  }
  prototype.toString = function(){
    return this.id;
  };
  return Player;
}());
players = function(it){
  return it.map(function(arg$, i){
    var w, l;
    w = arg$[0], l = arg$[1];
    return new Player(i, w, l);
  });
}([[5, 5], [6, 6], [7, 3], [3, 3]]);
bandwidth = 10;
byNeeded = comparator(function(it){
  return it.needed;
});
reallocate = function(){
  var offset, res$, i$, ref$, len$, p, o;
  allocs = maxMinFair(players, bandwidth);
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += allocs[p];
    res$.push(o);
  }
  stackAllocs = res$;
};
reallocate();
rescale = function(){
  var offset, res$, i$, ref$, len$, p, o;
  totalWanted = d3.sum(players, function(it){
    return it.wanted;
  });
  totalLimited = d3.sum(players, function(it){
    return it.limited;
  });
  scaleHeight = Math.max(totalLimited, totalWanted, bandwidth) + 1;
  wantedPadding = (scaleHeight - totalWanted) / (players.length - 1);
  limitedPadding = (scaleHeight - totalLimited) / (players.length - 1);
  yScale = d3.scale.linear().domain([0, scaleHeight]).range([0, height]);
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += p.wanted + wantedPadding;
    res$.push(o);
  }
  stackWanted = res$;
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += p.limited + wantedPadding;
    res$.push(o);
  }
  stackLimited = res$;
};
rescale();
drag = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(){
  bandwidth = Math.max(1, 2 * Math.abs(scaleHeight / 2 - yScale.invert(d3.event.y)));
  reallocate();
  drawSchematic();
}).on('dragend', function(){
  body.classed('dragging', false);
  rescale();
  drawSchematic();
});
handleTop.call(drag);
handleBot.call(drag);
curve = sections[1] / 3;
drawSchematic = function(){
  var startPipe, endPipe, x$, y$, z$;
  startPipe = scaleHeight / 2 - bandwidth / 2;
  endPipe = startPipe + bandwidth;
  handleTop.attr('y', yScale(startPipe) - handleHeight);
  handleBot.attr('y', yScale(endPipe));
  x$ = wants.selectAll('.want').data(players);
  x$.exit().remove();
  x$.enter().append('rect').attr({
    'class': function(it){
      return "want player-" + it;
    }
  });
  x$.attr({
    x: 0,
    y: function(p, i){
      return yScale(Math.max(stackLimited[i], stackWanted[i]));
    },
    width: sections[1] - sections[0],
    height: function(){
      return yScale(function(it){
        return it.wanted;
      }.apply(this, arguments));
    }
  });
  y$ = limits.selectAll('.limit').data(players);
  y$.exit().remove();
  y$.enter().append('rect').attr({
    'class': function(it){
      return "limit player-" + it;
    }
  });
  y$.attr({
    x: sections[4],
    y: function(p, i){
      return yScale(Math.max(stackLimited[i], stackWanted[i]));
    },
    width: sections[4] - sections[3],
    height: function(){
      return yScale(function(it){
        return it.limited;
      }.apply(this, arguments));
    }
  });
  z$ = paths.selectAll('.alloc').data(players);
  z$.exit().remove();
  z$.enter().append('path').attr({
    'class': function(it){
      return "alloc player-" + it;
    }
  });
  z$.attr({
    d: function(p, i){
      var start, endW, endL, a, endA;
      start = yScale(Math.max(stackLimited[i], stackWanted[i]));
      endW = start + yScale(p.limited);
      endL = start + yScale(allocs[i]);
      a = yScale(startPipe + stackAllocs[i]);
      endA = a + yScale(allocs[i]);
      return "M " + sections[0] + " " + start + "L " + sections[1] + " " + start + "C " + (sections[1] + curve) + " " + start + " " + (sections[2] - curve) + " " + a + " " + sections[2] + " " + a + "L " + sections[3] + " " + a + "C " + (sections[3] + curve) + " " + a + " " + (sections[4] - curve) + " " + start + " " + sections[4] + " " + start + "L " + sections[5] + " " + start + "L " + sections[5] + " " + endL + "L " + sections[4] + " " + endL + "C " + (sections[4] - curve) + " " + endL + " " + (sections[3] + curve) + " " + endA + " " + sections[3] + " " + endA + "L " + sections[2] + " " + endA + "C " + (sections[2] - curve) + " " + endA + " " + (sections[1] + curve) + " " + endW + " " + sections[1] + " " + endW + "L " + sections[0] + " " + endW + "Z";
    }
  });
};
drawSchematic();
function comparator(view){
  return function(a, b){
    return view(a) - view(b);
  };
}
function maxMinFair(players, bandwidth){
  var allocs, i, i$, ref$, len$, player, fair, alloc;
  allocs = {};
  i = players.length;
  for (i$ = 0, len$ = (ref$ = players.slice().sort(byNeeded)).length; i$ < len$; ++i$) {
    player = ref$[i$];
    fair = bandwidth / i--;
    alloc = player.needed > fair
      ? fair
      : player.needed;
    bandwidth -= alloc;
    allocs[player] = alloc;
  }
  return allocs;
}