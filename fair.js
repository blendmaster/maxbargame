// Generated by LiveScript 1.2.0
var height, width, sections, handleHeight, body, x$, lock, mode, y$, svg, pipe, paths, wants, limits, makeNew, pendingPlayer, z$, handles, handleTop, handleBot, id, Player, players, bandwidth, byNeeded, bySpace, allocs, stackAllocs, reallocate, drag, dragWanted, modeChange, dragLimited, newNeeded, newPlayer, curve, attr, drawSchematic;
height = 300;
width = 500;
sections = [0, width / 5, 2 * width / 5, 3 * width / 5, 4 * width / 5, 5 * width / 5];
handleHeight = 10;
body = d3.select(document.body);
x$ = lock = document.getElementById('lock');
x$.checked = true;
mode = document.getElementById('mode');
y$ = svg = d3.select('#svg');
y$.attr({
  width: width,
  height: height,
  viewBox: "0 0 " + width + " " + height,
  preserveAspectRatio: 'none'
});
pipe = y$.append('rect').attr({
  width: sections[1],
  x: sections[2],
  height: bandwidth
}).attr('id', 'pipe');
paths = y$.append('g').attr('id', 'paths');
wants = y$.append('g').attr('id', 'wants');
limits = y$.append('g').attr('id', 'limits');
makeNew = y$.append('rect').attr('id', 'make-new').attr({
  width: width,
  x: 0,
  height: 0
});
pendingPlayer = y$.append('path').attr('id', 'pending-player');
z$ = handles = y$.append('g').attr('id', 'handles');
handleTop = z$.append('rect').attr({
  id: 'handle-top',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
handleBot = z$.append('rect').attr({
  id: 'handle-bot',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
id = 0;
Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  function Player(wanted, limited){
    this.wanted = wanted;
    this.limited = limited;
    this.id = id++;
    this.color = this.id % 8;
    this.needed = Math.min(this.wanted, this.limited);
    this.space = Math.max(this.wanted, this.limited);
  }
  prototype.toString = function(){
    return this.id;
  };
  return Player;
}());
players = [new Player(50, 50)];
bandwidth = 100;
byNeeded = comparator(function(it){
  return it.needed;
});
bySpace = comparator(function(it){
  return it.space;
});
allocs = {};
reallocate = function(){
  var remaining, i$, ref$, len$, p, alloc, fair, sorted, offset;
  allocs = {};
  stackAllocs = {};
  switch (mode.value) {
  case 'first':
    remaining = bandwidth;
    for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
      p = ref$[i$];
      allocs[p] = alloc = Math.min(remaining, p.needed);
      remaining -= alloc;
    }
    break;
  case 'equal':
    fair = bandwidth / players.length;
    for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
      p = ref$[i$];
      allocs[p] = fair;
    }
    break;
  case 'fair':
    sorted = players.slice().sort(byNeeded);
    allocs = maxMinFair(sorted, bandwidth);
  }
  offset = 0;
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    stackAllocs[p] = offset;
    offset += allocs[p];
  }
};
reallocate();
drag = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(){
  bandwidth = Math.max(1, 2 * Math.abs(height / 2 - d3.event.y));
  reallocate();
  drawSchematic();
}).on('dragend', function(){
  body.classed('dragging', false);
  drawSchematic(1000);
});
handleTop.call(drag);
handleBot.call(drag);
dragWanted = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(player){
  player.wanted += d3.event.dy;
  player.wanted = Math.max(0, player.wanted);
  if (lock.checked) {
    player.limited = player.wanted;
  }
  player.needed = Math.min(player.wanted, player.limited);
  player.space = Math.max(player.wanted, player.limited);
  reallocate();
  drawSchematic();
}).on('dragend', function(player){
  var duration;
  if (player.needed < 5) {
    players.splice(players.indexOf(player), 1);
    duration = 1500;
  } else {
    duration = 0;
  }
  body.classed('dragging', false);
  reallocate();
  drawSchematic(duration);
});
modeChange = function(){
  reallocate();
  drawSchematic(1500);
};
mode.addEventListener('change', modeChange);
mode.addEventListener('keyup', modeChange);
dragLimited = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(player){
  player.limited += d3.event.dy;
  player.limited = Math.max(0, player.limited);
  if (lock.checked) {
    player.wanted = player.limited;
  }
  player.needed = Math.min(player.wanted, player.limited);
  player.space = Math.max(player.wanted, player.limited);
  reallocate();
  drawSchematic();
}).on('dragend', function(){
  var duration;
  if (player.needed < 5) {
    players.splice(players.indexOf(player), 1);
    duration = 1500;
  } else {
    duration = 0;
  }
  body.classed('dragging', false);
  reallocate();
  drawSchematic(duration);
});
newNeeded = 0;
makeNew.call(d3.behavior.drag().on('drag', function(){
  newNeeded += d3.event.dy;
  newNeeded = Math.max(0, newNeeded);
  drawSchematic();
}).on('dragend', function(){
  if (newNeeded > 5) {
    newPlayer = new Player(newNeeded, newNeeded);
    players.push(newPlayer);
  }
  newNeeded = 0;
  reallocate();
  drawSchematic(1000);
}));
curve = sections[1] / 3;
attr = function(sel, duration, attrs, val){
  if (duration > 0) {
    if (val != null) {
      return sel.transition().duration(duration).attr(attrs, val);
    } else {
      return sel.transition().duration(duration).attr(attrs);
    }
  } else {
    if (val != null) {
      return sel.attr(attrs, val);
    } else {
      return sel.attr(attrs);
    }
  }
};
drawSchematic = function(duration){
  var remaining, i, layout, i$, ref$, len$, p, equal, lay, offset, used, start, end, startPipe, endPipe, x$, y$, z$;
  duration == null && (duration = 0);
  remaining = height;
  i = players.length + 1;
  layout = {};
  for (i$ = 0, len$ = (ref$ = players.slice().sort(bySpace).reverse()).length; i$ < len$; ++i$) {
    p = ref$[i$];
    equal = remaining / i--;
    layout[p] = lay = p.space > equal ? p.space : equal;
    remaining -= lay;
  }
  offset = {};
  used = 0;
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    offset[p] = used + layout[p] / 2 - p.space / 2;
    used += layout[p];
  }
  makeNew.attr({
    height: remaining,
    y: used
  });
  start = used + remaining / 2 - newNeeded / 2;
  end = start + newNeeded;
  startPipe = height / 2 - bandwidth / 2;
  endPipe = startPipe + bandwidth;
  attr(handleTop, duration, 'y', startPipe - handleHeight);
  attr(handleBot, duration, 'y', endPipe);
  attr(pipe, duration, {
    y: startPipe,
    height: bandwidth
  });
  x$ = wants.selectAll('.want').data(players, function(it){
    return it.id;
  });
  x$.exit().transition(1000).style('opacity', 0).remove();
  x$.enter().append('rect').attr('class', function(it){
    return "want q" + it.color + "-8";
  }).call(dragWanted).attr({
    x: 0,
    width: sections[1] - sections[0],
    height: 0
  }).attr('y', function(it){
    if (it === newPlayer) {
      return start;
    }
  });
  attr(x$, duration, {
    x: 0,
    y: function(it){
      return offset[it];
    },
    height: function(it){
      return it.wanted;
    }
  });
  y$ = limits.selectAll('.limit').data(players, function(it){
    return it.id;
  });
  y$.exit().transition(1000).style('opacity', 0).remove();
  y$.enter().append('rect').attr('class', function(it){
    return "limit q" + it.color + "-8";
  }).attr({
    x: sections[4],
    width: sections[4] - sections[3],
    height: 0
  }).attr('y', function(it){
    if (it === newPlayer) {
      return start;
    }
  }).call(dragLimited);
  attr(y$, duration, {
    y: function(it){
      return offset[it];
    },
    height: function(it){
      return it.limited;
    }
  });
  z$ = paths.selectAll('.alloc').data(players, function(it){
    return it.id;
  });
  z$.exit().transition(1000).style('opacity', 0).remove();
  z$.enter().append('path').attr({
    'class': function(it){
      return "alloc q" + it.color + "-8";
    },
    d: function(it){
      if (it === newPlayer) {
        return pendingPlayer.attr('d');
      } else {
        return null;
      }
    }
  });
  attr(z$, duration, {
    d: function(p){
      var thickness, start, endW, endL, a, endA;
      thickness = Math.min(p.limited, p.wanted, allocs[p]);
      start = offset[p];
      endW = start + thickness;
      endL = start + thickness;
      a = startPipe + stackAllocs[p];
      endA = a + thickness;
      return "M " + sections[0] + " " + start + "L " + sections[1] + " " + start + "C " + (sections[1] + curve) + " " + start + " " + (sections[2] - curve) + " " + a + " " + sections[2] + " " + a + "L " + sections[3] + " " + a + "C " + (sections[3] + curve) + " " + a + " " + (sections[4] - curve) + " " + start + " " + sections[4] + " " + start + "L " + sections[5] + " " + start + "L " + sections[5] + " " + endL + "L " + sections[4] + " " + endL + "C " + (sections[4] - curve) + " " + endL + " " + (sections[3] + curve) + " " + endA + " " + sections[3] + " " + endA + "L " + sections[2] + " " + endA + "C " + (sections[2] - curve) + " " + endA + " " + (sections[1] + curve) + " " + endW + " " + sections[1] + " " + endW + "L " + sections[0] + " " + endW + "Z";
    }
  });
  pendingPlayer.attr('d', "M " + sections[0] + " " + start + "L " + sections[1] + " " + start + "C " + (sections[1] + curve) + " " + start + " " + (sections[2] - curve) + " " + start + " " + sections[2] + " " + start + "L " + sections[3] + " " + start + "C " + (sections[3] + curve) + " " + start + " " + (sections[4] - curve) + " " + start + " " + sections[4] + " " + start + "L " + sections[5] + " " + start + "L " + sections[5] + " " + end + "L " + sections[4] + " " + end + "C " + (sections[4] - curve) + " " + end + " " + (sections[3] + curve) + " " + end + " " + sections[3] + " " + end + "L " + sections[2] + " " + end + "C " + (sections[2] - curve) + " " + end + " " + (sections[1] + curve) + " " + end + " " + sections[1] + " " + end + "L " + sections[0] + " " + end + "Z");
  pendingPlayer.attr('class', "q" + id % 8 + "-8");
};
drawSchematic();
function comparator(view){
  return function(a, b){
    return view(a) - view(b);
  };
}
function maxMinFair(players, bandwidth){
  var allocs, i, i$, len$, player, fair, alloc;
  allocs = {};
  i = players.length;
  for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
    player = players[i$];
    fair = bandwidth / i--;
    alloc = player.needed > fair
      ? fair
      : player.needed;
    bandwidth -= alloc;
    allocs[player] = alloc;
  }
  return allocs;
}