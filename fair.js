// Generated by LiveScript 1.2.0
var height, width, sections, handleHeight, body, x$, svg, wants, paths, limits, y$, handles, handleTop, handleBot, Player, players, bandwidth, byNeeded, allocs, stackAllocs, reallocate, delayIdx, i$, len$, i, p, yScale, scaleHeight, stackWanted, stackLimited, rescale, drag, dragWanted, dragLimited, curve, attr, drawSchematic;
height = 400;
width = 500;
sections = [0, width / 5, 2 * width / 5, 3 * width / 5, 4 * width / 5, 5 * width / 5];
handleHeight = 10;
body = d3.select(document.body);
x$ = svg = d3.select('#svg').attr({
  width: width,
  height: height
});
wants = x$.append('g').attr('id', 'wants');
paths = x$.append('g').attr('id', 'paths');
limits = x$.append('g').attr('id', 'limits');
y$ = handles = x$.append('g').attr('id', 'handles');
handleTop = y$.append('rect').attr({
  id: 'handle-top',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
handleBot = y$.append('rect').attr({
  id: 'handle-bot',
  x: sections[2],
  width: sections[1],
  height: handleHeight
});
Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  function Player(id, wanted, limited){
    this.id = id;
    this.wanted = wanted;
    this.limited = limited;
    this.needed = Math.min(this.wanted, this.limited);
  }
  prototype.toString = function(){
    return this.id;
  };
  return Player;
}());
players = function(it){
  return it.map(function(arg$, i){
    var w, l;
    w = arg$[0], l = arg$[1];
    return new Player(i, w, l);
  });
}([[5, 5], [6, 6], [7, 3], [3, 3]]);
bandwidth = 10;
byNeeded = comparator(function(it){
  return it.needed;
});
reallocate = function(){
  var sorted, offset, res$, i$, ref$, len$, p, o;
  sorted = players.slice().sort(byNeeded);
  allocs = maxMinFair(sorted, bandwidth);
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += allocs[p];
    res$.push(o);
  }
  stackAllocs = res$;
};
reallocate();
delayIdx = {};
for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
  i = i$;
  p = players[i$];
  delayIdx[p] = i;
}
rescale = function(){
  var max, offset, res$, i$, ref$, len$, p, o;
  max = d3.sum(players, function(it){
    return Math.max(it.wanted, it.limited);
  });
  scaleHeight = Math.max(max, bandwidth);
  yScale = d3.scale.linear().domain([0, scaleHeight]).range([0, height]);
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += p.wanted;
    res$.push(o);
  }
  stackWanted = res$;
  offset = 0;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    p = ref$[i$];
    o = offset;
    offset += p.limited;
    res$.push(o);
  }
  stackLimited = res$;
};
rescale();
drag = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(){
  bandwidth = Math.max(1, 2 * Math.abs(scaleHeight / 2 - yScale.invert(d3.event.y)));
  reallocate();
  drawSchematic();
}).on('dragend', function(){
  body.classed('dragging', false);
  rescale();
  drawSchematic(1000);
});
handleTop.call(drag);
handleBot.call(drag);
dragWanted = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(player){
  var i$, ref$, len$, i, p;
  player.wanted += yScale.invert(d3.event.dy);
  player.wanted = Math.max(1, player.wanted);
  player.needed = Math.min(player.wanted, player.limited);
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    i = i$;
    p = ref$[i$];
    delayIdx[p] = p === player
      ? 0
      : p.id > player.id
        ? i
        : i + 1;
  }
  drawSchematic();
}).on('dragend', function(){
  body.classed('dragging', false);
  reallocate();
  rescale();
  drawSchematic(1000);
});
dragLimited = d3.behavior.drag().on('dragstart', function(){
  body.classed('dragging', true);
}).on('drag', function(player){
  var i$, ref$, len$, i, p;
  player.limited += yScale.invert(d3.event.dy);
  player.limited = Math.max(1, player.limited);
  player.needed = Math.min(player.wanted, player.limited);
  for (i$ = 0, len$ = (ref$ = players).length; i$ < len$; ++i$) {
    i = i$;
    p = ref$[i$];
    delayIdx[p] = p === player
      ? 0
      : p.id > player.id
        ? i
        : i + 1;
  }
  drawSchematic();
}).on('dragend', function(){
  body.classed('dragging', false);
  reallocate();
  rescale();
  drawSchematic(1000);
});
curve = sections[1] / 3;
attr = function(sel, duration, delay, attrs, val){
  if (duration > 0) {
    if (val != null) {
      return sel.transition(duration).delay(delay).attr(attrs, val);
    } else {
      return sel.transition(duration).delay(delay).attr(attrs);
    }
  } else {
    if (val != null) {
      return sel.attr(attrs, val);
    } else {
      return sel.attr(attrs);
    }
  }
};
drawSchematic = function(duration){
  var startPipe, endPipe, delay, x$, y$, z$;
  duration == null && (duration = 0);
  startPipe = scaleHeight / 2 - bandwidth / 2;
  endPipe = startPipe + bandwidth;
  delay = function(d, i){
    return 1000 * delayIdx[d] / players.length;
  };
  attr(handleTop, duration, 0, 'y', yScale(startPipe) - handleHeight);
  attr(handleBot, duration, 0, 'y', yScale(endPipe));
  x$ = wants.selectAll('.want').data(players);
  x$.exit().remove();
  x$.enter().append('rect').attr('class', function(it){
    return "want player-" + it;
  }).call(dragWanted).attr({
    x: 0,
    width: sections[1] - sections[0]
  });
  attr(x$, duration, delay, {
    x: 0,
    y: function(p, i){
      return yScale(Math.max(stackLimited[i], stackWanted[i]));
    },
    height: function(){
      return yScale(function(it){
        return it.wanted;
      }.apply(this, arguments));
    }
  });
  y$ = limits.selectAll('.limit').data(players);
  y$.exit().remove();
  y$.enter().append('rect').attr('class', function(it){
    return "limit player-" + it;
  }).attr({
    x: sections[4],
    width: sections[4] - sections[3]
  }).call(dragLimited);
  attr(y$, duration, delay, {
    y: function(p, i){
      return yScale(Math.max(stackLimited[i], stackWanted[i]));
    },
    height: function(){
      return yScale(function(it){
        return it.limited;
      }.apply(this, arguments));
    }
  });
  z$ = paths.selectAll('.alloc').data(players);
  z$.exit().remove();
  z$.enter().append('path').attr({
    'class': function(it){
      return "alloc player-" + it;
    }
  });
  attr(z$, duration, delay, {
    d: function(p, i){
      var thickness, start, endW, endL, a, endA;
      thickness = yScale(Math.min(p.limited, p.wanted, allocs[p]));
      start = yScale(Math.max(stackLimited[i], stackWanted[i]));
      endW = start + thickness;
      endL = start + thickness;
      a = yScale(startPipe + stackAllocs[i]);
      endA = a + thickness;
      return "M " + sections[0] + " " + start + "L " + sections[1] + " " + start + "C " + (sections[1] + curve) + " " + start + " " + (sections[2] - curve) + " " + a + " " + sections[2] + " " + a + "L " + sections[3] + " " + a + "C " + (sections[3] + curve) + " " + a + " " + (sections[4] - curve) + " " + start + " " + sections[4] + " " + start + "L " + sections[5] + " " + start + "L " + sections[5] + " " + endL + "L " + sections[4] + " " + endL + "C " + (sections[4] - curve) + " " + endL + " " + (sections[3] + curve) + " " + endA + " " + sections[3] + " " + endA + "L " + sections[2] + " " + endA + "C " + (sections[2] - curve) + " " + endA + " " + (sections[1] + curve) + " " + endW + " " + sections[1] + " " + endW + "L " + sections[0] + " " + endW + "Z";
    }
  });
};
drawSchematic();
function comparator(view){
  return function(a, b){
    return view(a) - view(b);
  };
}
function maxMinFair(players, bandwidth){
  var allocs, i, i$, len$, player, fair, alloc;
  allocs = {};
  i = players.length;
  for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
    player = players[i$];
    fair = bandwidth / i--;
    alloc = player.needed > fair
      ? fair
      : player.needed;
    bandwidth -= alloc;
    allocs[player] = alloc;
  }
  return allocs;
}