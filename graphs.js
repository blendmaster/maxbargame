// Generated by LiveScript 1.2.0
var id, log, Value, Vertex, Edge, Player, DisjointSet, Strategy, State;
id = 0;
log = function(){};
Value = (function(){
  Value.displayName = 'Value';
  var prototype = Value.prototype, constructor = Value;
  prototype.toString = function(){
    return this.id;
  };
  function Value(){}
  return Value;
}());
Vertex = (function(superclass){
  var prototype = extend$((import$(Vertex, superclass).displayName = 'Vertex', Vertex), superclass).prototype, constructor = Vertex;
  function Vertex(x, y){
    this.x = x;
    this.y = y;
    this.id = id++;
    this.edges = [];
    this.neighbors = {};
    this.srobhgien = {};
    this.player = void 8;
  }
  return Vertex;
}(Value));
Edge = (function(superclass){
  var prototype = extend$((import$(Edge, superclass).displayName = 'Edge', Edge), superclass).prototype, constructor = Edge;
  function Edge($0, $1, bandwidth){
    this[0] = $0;
    this[1] = $1;
    this.bandwidth = bandwidth;
    this.source = this[0];
    this.target = this[1];
    this.id = id++;
    this.length = 2;
    this[0].edges.push(this);
    this[1].edges.push(this);
    this[0].neighbors[this] = this[1];
    this[1].neighbors[this] = this[0];
    this[0].srobhgien[this[1]] = this;
    this[1].srobhgien[this[0]] = this;
  }
  return Edge;
}(Value));
Player = (function(superclass){
  var prototype = extend$((import$(Player, superclass).displayName = 'Player', Player), superclass).prototype, constructor = Player;
  function Player($0, $1){
    this[0] = $0;
    this[1] = $1;
    this.id = id++;
    this.length = 2;
    this[0].player = this;
    this[1].player = this;
  }
  return Player;
}(Value));
DisjointSet = (function(){
  DisjointSet.displayName = 'DisjointSet';
  var prototype = DisjointSet.prototype, constructor = DisjointSet;
  function DisjointSet(){
    this.parent = this;
    this.rank = 0;
  }
  prototype.root = function(){
    if (this.parent !== this) {
      this.parent = this.parent.root();
    }
    return this.parent;
  };
  prototype.union = function(it){
    var root, other;
    root = this.root();
    other = it.root();
    if (root !== other) {
      if (root.rank < other.rank) {
        root.parent = other;
      } else if (root.rank > other.rank) {
        other.parent = root;
      } else {
        other.parent = root;
        root.rank++;
      }
    }
  };
  return DisjointSet;
}());
function maxCapacityPath(topology, weights, arg$){
  var start, end, sets, i$, ref$, len$, vertex, edges, treeEdges, edge, u, v, us, vs, seen, vPath, path, neighbor;
  start = arg$[0], end = arg$[1];
  sets = {};
  for (i$ = 0, len$ = (ref$ = topology.vertices).length; i$ < len$; ++i$) {
    vertex = ref$[i$];
    sets[vertex] = new DisjointSet;
  }
  edges = topology.edges.slice().sort(function(a, b){
    return weights[b] - weights[a];
  });
  treeEdges = {};
  for (i$ = 0, len$ = edges.length; i$ < len$; ++i$) {
    edge = edges[i$], u = edge[0], v = edge[1];
    us = sets[u];
    vs = sets[v];
    if (us.root() !== vs.root()) {
      treeEdges[edge] = true;
      us.union(vs);
    }
  }
  seen = {};
  vPath = [start];
  path = [];
  outer: while (vertex = vPath[vPath.length - 1]) {
    seen[vertex] = true;
    for (edge in ref$ = vertex.neighbors) {
      neighbor = ref$[edge];
      if (treeEdges[edge] && !seen[neighbor]) {
        vPath.push(neighbor);
        path.push(vertex.srobhgien[neighbor]);
        if (neighbor === end) {
          return path;
        } else {
          continue outer;
        }
      }
    }
    path.pop();
    vPath.pop();
  }
  throw new Error("no path found somehow!");
}
function observedAvailableBandwidth(edge, allocs){
  var residual, sharing, i$, len$, alloc, fair;
  residual = edge.bandwidth;
  sharing = allocs.length + 1;
  for (i$ = 0, len$ = allocs.length; i$ < len$; ++i$) {
    alloc = allocs[i$];
    fair = residual / sharing;
    if (alloc <= fair) {
      residual -= alloc;
      sharing--;
    } else {
      residual = fair;
      break;
    }
  }
  return residual;
}
function bestResponse(topology, player, strategy, opponents){
  var strategies, allocs, i$, len$, s, j$, ref$, len1$, edge, available, mcp;
  strategies = opponents.sort(function(a, b){
    return a.bandwidth - b.bandwidth;
  });
  log(player + " vs: " + opponents.map(function(it){
    return it.path;
  }));
  allocs = {};
  for (i$ = 0, len$ = strategies.length; i$ < len$; ++i$) {
    s = strategies[i$];
    for (j$ = 0, len1$ = (ref$ = s.path).length; j$ < len1$; ++j$) {
      edge = ref$[j$];
      (allocs[edge] || (allocs[edge] = [])).push(s.bandwidth);
    }
  }
  available = {};
  for (i$ = 0, len$ = (ref$ = topology.edges).length; i$ < len$; ++i$) {
    edge = ref$[i$];
    available[edge] = observedAvailableBandwidth(edge, allocs[edge] || []);
    log(edge + " : " + available[edge] + " / " + edge.bandwidth + ", used by " + allocs[edge]);
  }
  mcp = maxCapacityPath(topology, available, player);
  return {
    path: mcp,
    bandwidth: d3.min(mcp, function(it){
      return available[it];
    })
  };
}
Strategy = (function(){
  Strategy.displayName = 'Strategy';
  var prototype = Strategy.prototype, constructor = Strategy;
  function Strategy(path, bottleneck, bandwidth){
    this.path = path;
    this.bottleneck = bottleneck;
    this.bandwidth = bandwidth;
  }
  return Strategy;
}());
State = (function(){
  State.displayName = 'State';
  var prototype = State.prototype, constructor = State;
  function State(strategies, turn){
    this.strategies = strategies;
    this.turn = turn;
  }
  return State;
}());
function allocate(topology, paths){
  var residuals, i$, ref$, len$, edge, remaining, res$, player, strategies, users, globalBottleneck, bottlenecked, alloc, j$, len1$;
  residuals = {};
  for (i$ = 0, len$ = (ref$ = topology.edges).length; i$ < len$; ++i$) {
    edge = ref$[i$];
    residuals[edge] = edge.bandwidth;
  }
  res$ = {};
  for (player in paths) {
    res$[player] = true;
  }
  remaining = res$;
  strategies = {};
  while (Object.keys(remaining).length > 0) {
    users = {};
    for (player in remaining) {
      for (i$ = 0, len$ = (ref$ = paths[player]).length; i$ < len$; ++i$) {
        edge = ref$[i$];
        (users[edge] || (users[edge] = [])).push(player);
      }
    }
    globalBottleneck = minBy(topology.edges, fn$);
    bottlenecked = users[globalBottleneck];
    alloc = residuals[globalBottleneck] / bottlenecked.length;
    log(globalBottleneck + " is bottleneck, used by " + bottlenecked + " => " + alloc);
    for (i$ = 0, len$ = bottlenecked.length; i$ < len$; ++i$) {
      player = bottlenecked[i$];
      strategies[player] = new Strategy(paths[player], globalBottleneck, alloc);
      delete remaining[player];
      for (j$ = 0, len1$ = (ref$ = paths[player]).length; j$ < len1$; ++j$) {
        edge = ref$[j$];
        log("decreasing " + edge + " residual " + residuals[edge] + " - " + alloc + " = " + (residuals[edge] - alloc));
        residuals[edge] -= alloc;
      }
    }
  }
  return strategies;
  function fn$(edge){
    var ref$;
    return residuals[edge] / (((ref$ = users[edge]) != null ? ref$.length : void 8) || 0);
  }
}
function minBy(arr, view){
  var min, minV, i$, x$, len$, v;
  min = Infinity;
  minV = void 8;
  for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
    x$ = arr[i$];
    v = view(x$);
    if (min > v) {
      minV = x$;
      min = v;
    }
  }
  return minV;
}
function maxbargame(topology, players, strategies){
  var states, iterations, equilibrium, i$, len$, player, strategy, br, nextPaths, p, next;
  states = [new State(strategies)];
  iterations = 0;
  do {
    equilibrium = true;
    for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
      player = players[i$];
      strategy = strategies[player];
      br = bestResponse(topology, player, strategy, players.filter((fn$)).map(fn1$));
      log(player + ": " + strategy.path + " (" + strategy.bandwidth + ") => " + br.path + " (" + br.bandwidth + ")");
      if (br.bandwidth > strategy.bandwidth) {
        log("found better!");
        equilibrium = false;
        nextPaths = {};
        for (p in strategies) {
          strategy = strategies[p];
          nextPaths[p] = strategy.path;
        }
        nextPaths[player] = br.path;
        next = allocate(topology, nextPaths);
        log(next);
      } else {
        log("no better...");
      }
      states.push(new State(next, player));
      strategies = next;
    }
    iterations++;
  } while (!equilibrium && iterations < 10);
  return states;
  function fn$(it){
    return it !== player;
  }
  function fn1$(it){
    return strategies[it];
  }
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}