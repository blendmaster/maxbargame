// Generated by LiveScript 1.2.0
var id, log, Value, Vertex, Edge, Player, DisjointSet, Strategy, State;
id = 0;
log = function(){};
Value = (function(){
  Value.displayName = 'Value';
  var prototype = Value.prototype, constructor = Value;
  prototype.toString = function(){
    return this.id;
  };
  function Value(){}
  return Value;
}());
Vertex = (function(superclass){
  var prototype = extend$((import$(Vertex, superclass).displayName = 'Vertex', Vertex), superclass).prototype, constructor = Vertex;
  function Vertex(){
    this.x = this.y = void 8;
    this.id = id++;
    this.edges = [];
    this.neighbors = {};
    this.srobhgien = {};
    this.player = void 8;
  }
  return Vertex;
}(Value));
Edge = (function(superclass){
  var prototype = extend$((import$(Edge, superclass).displayName = 'Edge', Edge), superclass).prototype, constructor = Edge;
  function Edge($0, $1, bandwidth){
    this[0] = $0;
    this[1] = $1;
    this.bandwidth = bandwidth;
    this.source = this[0];
    this.target = this[1];
    this.id = id++;
    this.length = 2;
    this[0].edges.push(this);
    this[1].edges.push(this);
    this[0].neighbors[this] = this[1];
    this[1].neighbors[this] = this[0];
    this[0].srobhgien[this[1]] = this;
    this[1].srobhgien[this[0]] = this;
  }
  return Edge;
}(Value));
Player = (function(superclass){
  var prototype = extend$((import$(Player, superclass).displayName = 'Player', Player), superclass).prototype, constructor = Player;
  function Player($0, $1){
    this[0] = $0;
    this[1] = $1;
    this.id = id++;
    this.length = 2;
    this[0].player = this;
    this[1].player = this;
  }
  return Player;
}(Value));
DisjointSet = (function(){
  DisjointSet.displayName = 'DisjointSet';
  var prototype = DisjointSet.prototype, constructor = DisjointSet;
  function DisjointSet(){
    this.parent = this;
    this.rank = 0;
  }
  prototype.root = function(){
    if (this.parent !== this) {
      this.parent = this.parent.root();
    }
    return this.parent;
  };
  prototype.union = function(it){
    var root, other;
    root = this.root();
    other = it.root();
    if (root !== other) {
      if (root.rank < other.rank) {
        root.parent = other;
      } else if (root.rank > other.rank) {
        other.parent = root;
      } else {
        other.parent = root;
        root.rank++;
      }
    }
  };
  return DisjointSet;
}());
function maxCapacityPath(topology, weights, arg$){
  var start, end, sets, i$, ref$, len$, vertex, edges, treeEdges, edge, u, v, us, vs, seen, vPath, path, neighbor;
  start = arg$[0], end = arg$[1];
  sets = {};
  for (i$ = 0, len$ = (ref$ = topology.vertices).length; i$ < len$; ++i$) {
    vertex = ref$[i$];
    sets[vertex] = new DisjointSet;
  }
  edges = topology.edges.slice().sort(function(a, b){
    return weights[b] - weights[a];
  });
  treeEdges = {};
  for (i$ = 0, len$ = edges.length; i$ < len$; ++i$) {
    edge = edges[i$], u = edge[0], v = edge[1];
    us = sets[u];
    vs = sets[v];
    if (us.root() !== vs.root()) {
      treeEdges[edge] = true;
      us.union(vs);
    }
  }
  seen = {};
  vPath = [start];
  path = [];
  outer: while (vertex = vPath[vPath.length - 1]) {
    seen[vertex] = true;
    for (edge in ref$ = vertex.neighbors) {
      neighbor = ref$[edge];
      if (treeEdges[edge] && !seen[neighbor]) {
        vPath.push(neighbor);
        path.push(vertex.srobhgien[neighbor]);
        if (neighbor === end) {
          return path;
        } else {
          continue outer;
        }
      }
    }
    path.pop();
    vPath.pop();
  }
  throw new Error("no path found somehow!");
}
function observedAvailableBandwidth(edge, allocs){
  var residual, sharing, i$, len$, alloc, fair;
  residual = edge.bandwidth;
  sharing = allocs.length + 1;
  for (i$ = 0, len$ = allocs.length; i$ < len$; ++i$) {
    alloc = allocs[i$];
    fair = residual / sharing;
    if (alloc <= fair) {
      residual -= alloc;
      sharing--;
    } else {
      residual = fair;
      break;
    }
  }
  return residual;
}
function bestResponse(topology, player, strategy, opponents){
  var strategies, allocs, i$, len$, s, j$, ref$, len1$, edge, available, mcp;
  strategies = opponents.sort(function(a, b){
    return a.bandwidth - b.bandwidth;
  });
  log(player + " vs: " + opponents.map(function(it){
    return it.path;
  }));
  allocs = {};
  for (i$ = 0, len$ = strategies.length; i$ < len$; ++i$) {
    s = strategies[i$];
    for (j$ = 0, len1$ = (ref$ = s.path).length; j$ < len1$; ++j$) {
      edge = ref$[j$];
      (allocs[edge] || (allocs[edge] = [])).push(s.bandwidth);
    }
  }
  available = {};
  for (i$ = 0, len$ = (ref$ = topology.edges).length; i$ < len$; ++i$) {
    edge = ref$[i$];
    available[edge] = observedAvailableBandwidth(edge, allocs[edge] || []);
    log(edge + " : " + available[edge] + " / " + edge.bandwidth + ", used by " + allocs[edge]);
  }
  mcp = maxCapacityPath(topology, available, player);
  return {
    path: mcp,
    bandwidth: d3.min(mcp, function(it){
      return available[it];
    })
  };
}
Strategy = (function(){
  Strategy.displayName = 'Strategy';
  var prototype = Strategy.prototype, constructor = Strategy;
  function Strategy(path, bottleneck, bandwidth){
    this.path = path;
    this.bottleneck = bottleneck;
    this.bandwidth = bandwidth;
  }
  return Strategy;
}());
State = (function(superclass){
  var prototype = extend$((import$(State, superclass).displayName = 'State', State), superclass).prototype, constructor = State;
  function State(strategies, player){
    this.strategies = strategies;
    this.player = player;
    this.id = id++;
  }
  return State;
}(Value));
function allocate(topology, paths){
  var residuals, i$, ref$, len$, edge, remaining, res$, player, strategies, users, globalBottleneck, bottlenecked, necks, alloc, j$, len1$;
  residuals = {};
  for (i$ = 0, len$ = (ref$ = topology.edges).length; i$ < len$; ++i$) {
    edge = ref$[i$];
    residuals[edge] = edge.bandwidth;
  }
  res$ = {};
  for (player in paths) {
    res$[player] = true;
  }
  remaining = res$;
  strategies = {};
  while (Object.keys(remaining).length > 0) {
    users = {};
    for (player in remaining) {
      for (i$ = 0, len$ = (ref$ = paths[player]).length; i$ < len$; ++i$) {
        edge = ref$[i$];
        (users[edge] || (users[edge] = [])).push(player);
      }
    }
    globalBottleneck = minBy(topology.edges, fn$);
    bottlenecked = users[globalBottleneck];
    if (bottlenecked == null) {
      necks = topology.edges.map(fn1$);
      debugger;
    }
    alloc = residuals[globalBottleneck] / bottlenecked.length;
    log(globalBottleneck + " is bottleneck, used by " + bottlenecked + " => " + alloc);
    for (i$ = 0, len$ = bottlenecked.length; i$ < len$; ++i$) {
      player = bottlenecked[i$];
      strategies[player] = new Strategy(paths[player], globalBottleneck, alloc);
      delete remaining[player];
      for (j$ = 0, len1$ = (ref$ = paths[player]).length; j$ < len1$; ++j$) {
        edge = ref$[j$];
        log("decreasing " + edge + " residual " + residuals[edge] + " - " + alloc + " = " + (residuals[edge] - alloc));
        residuals[edge] -= alloc;
        residuals[edge] = Math.max(0, residuals[edge]);
      }
    }
  }
  return strategies;
  function fn$(edge){
    var ref$;
    if (residuals[edge] === 0) {
      return Infinity;
    } else {
      return residuals[edge] / (((ref$ = users[edge]) != null ? ref$.length : void 8) || 0);
    }
  }
  function fn1$(edge){
    var ref$;
    return residuals[edge] + " " + users[edge] + " " + residuals[edge] / (((ref$ = users[edge]) != null ? ref$.length : void 8) || 0);
  }
}
function minBy(arr, view){
  var min, minV, i$, x$, len$, v, ids, vs;
  min = Infinity;
  minV = void 8;
  for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
    x$ = arr[i$];
    v = view(x$);
    if (min > v) {
      minV = x$;
      min = v;
    }
  }
  if (minV == null) {
    ids = arr.map(function(it){
      return it.id;
    });
    vs = arr.map(view);
    debugger;
  }
  return minV;
}
function maxbargame(topology, players, strategies, player){
  var state, better, strategy, br, nextPaths, p, next;
  state = new State(strategies, player);
  better = false;
  strategy = strategies[player];
  br = bestResponse(topology, player, strategy, players.filter((function(it){
    return it !== player;
  })).map(function(it){
    return strategies[it];
  }));
  log(player + ": " + strategy.path + " (" + strategy.bandwidth + ") => " + br.path + " (" + br.bandwidth + ")");
  nextPaths = {};
  for (p in strategies) {
    strategy = strategies[p];
    nextPaths[p] = strategy.path;
  }
  if (br.bandwidth > strategy.bandwidth) {
    log("found better!");
    better = true;
    nextPaths[player] = br.path;
  } else {
    log("no better...");
  }
  next = allocate(topology, nextPaths);
  return {
    better: better,
    state: new State(next)
  };
}
function connected(topology, without){
  var seen, count, stack, v, e, ref$, neighbor;
  if (topology.vertices.length < 1) {
    return false;
  }
  seen = {};
  count = 1;
  stack = [];
  if (topology.vertices[0] !== without) {
    stack.push(topology.vertices[0]);
  } else {
    stack.push(topology.vertices[1]);
  }
  seen[stack[0]] = true;
  while (stack.length > 0) {
    v = stack.pop();
    for (e in ref$ = v.neighbors) {
      neighbor = ref$[e];
      if (!seen[neighbor] && neighbor !== without) {
        seen[neighbor] = true;
        count++;
        stack.push(neighbor);
      }
    }
  }
  if (without != null) {
    return count === topology.vertices.length - 1;
  } else {
    return count === topology.vertices.length;
  }
}
function randInt(min, max){
  return Math.random() * (max - min) + min;
}
function randomTopology(numPlayers, numVertices, edgeProb){
  var vertices, res$, i$, i, edges, j$, j, weights, len$, e, paths, players, v1, r, v2, p;
  res$ = [];
  for (i$ = 0; i$ < numVertices; ++i$) {
    i = i$;
    res$.push(new Vertex);
  }
  vertices = res$;
  res$ = [];
  for (i$ = 0; i$ < numVertices; ++i$) {
    i = i$;
    res$.push(new Edge(vertices[i], vertices[(i + 1) % vertices.length], randInt(3, 10)));
  }
  edges = res$;
  for (i$ = 0; i$ < numVertices; ++i$) {
    i = i$;
    for (j$ = i + 2; j$ < numVertices; ++j$) {
      j = j$;
      if (Math.random() < edgeProb) {
        edges.push(new Edge(vertices[i], vertices[j], randInt(3, 10)));
      }
    }
  }
  weights = {};
  for (i$ = 0, len$ = edges.length; i$ < len$; ++i$) {
    e = edges[i$];
    weights[e] = e.bandwidth;
  }
  paths = {};
  res$ = [];
  for (i$ = 0; i$ < numPlayers; ++i$) {
    i = i$;
    v1 = vertices[r = Math.floor(Math.random() * vertices.length)];
    v2 = vertices[Math.floor(Math.random() * vertices.length)];
    if (v2 === v1) {
      v2 = vertices[(r + 1) % vertices.length];
    }
    p = new Player(v1, v2);
    paths[p] = maxCapacityPath({
      edges: edges,
      vertices: vertices
    }, weights, [v1, v2]);
    res$.push(p);
  }
  players = res$;
  if (!connected({
    edges: edges,
    vertices: vertices
  })) {
    throw new Error("not connected");
  }
  return {
    vertices: vertices,
    edges: edges,
    players: players,
    paths: paths
  };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}