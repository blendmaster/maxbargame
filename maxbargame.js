// Generated by LiveScript 1.2.0
var width, height, vertices, edges, topology, players, pathIdx, playerColor, paths, i$, len$, i, p, game, strokeScale, force, idx, state, users, allocLine, transition, fadeOut, draw;
width = 500;
height = 500;
vertices = d3.range(9).map(function(){
  return new Vertex;
});
edges = function(it){
  return it.map(function(arg$){
    var s, t, b;
    s = arg$[0], t = arg$[1], b = arg$[2];
    return new Edge(vertices[s], vertices[t], b);
  });
}([[0, 1, 10], [1, 2, 7], [2, 3, 15], [3, 4, 5], [3, 6, 10], [6, 5, 9], [1, 6, 20], [1, 8, 10], [8, 7, 6], [6, 7, 5]]);
topology = {
  vertices: vertices,
  edges: edges
};
players = function(it){
  return it.map(function(arg$){
    var s, t;
    s = arg$[0], t = arg$[1];
    return new Player(vertices[s], vertices[t]);
  });
}([[0, 6], [8, 3], [5, 2]]);
pathIdx = function(it){
  return it.map(function(it){
    return it.map(function(it){
      return edges[it];
    });
  });
}([[0, 1, 2, 4], [8, 9, 4], [5, 4, 2]]);
playerColor = d3.scale.ordinal().range(colorbrewer.Dark2[8]);
paths = {};
for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
  i = i$;
  p = players[i$];
  paths[p] = pathIdx[i];
}
game = maxbargame(topology, players, allocate(topology, paths));
strokeScale = 2;
force = d3.layout.force().size([width, height]).nodes(vertices).links(edges).linkDistance(100).charge(-500);
idx = 0;
state = game[idx];
users = {};
(function(){
  var player, ref$, strategy, i$, ref1$, len$, edge;
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
}.call(this));
document.getElementById('play-pause').addEventListener('click', function(){
  var player, ref$, strategy, i$, ref1$, len$, edge;
  idx++;
  state = game[idx];
  users = {};
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
  force.stop();
  draw(2000);
});
allocLine = curry$(function(state, users, player, edge){
  var strategy, ref$, x1, y1, x2, y2, offsetStart, i$, len$, u, b, offsetMid, offsetEnd, offset, angle, xOffset, yOffset;
  strategy = state.strategies[player];
  ref$ = edge[0], x1 = ref$.x, y1 = ref$.y;
  ref$ = edge[1], x2 = ref$.x, y2 = ref$.y;
  offsetStart = 0;
  for (i$ = 0, len$ = (ref$ = users[edge]).length; i$ < len$; ++i$) {
    u = ref$[i$];
    if (u === player + "") {
      break;
    }
    offsetStart += state.strategies[u].bandwidth;
  }
  b = strategy.bandwidth;
  offsetMid = offsetStart + b / 2;
  offsetEnd = offsetStart + b;
  offset = offsetMid - edge.bandwidth / 2;
  offset *= strokeScale;
  angle = Math.atan2(y1 - y2, x2 - x1);
  xOffset = offset * Math.sin(angle);
  yOffset = offset * Math.cos(angle);
  x1 += xOffset;
  x2 += xOffset;
  y1 += yOffset;
  y2 += yOffset;
  return {
    angle: angle,
    offsetStart: offsetStart,
    offsetEnd: offsetEnd,
    offset: offset,
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    bottleneck: edge === strategy.bottleneck
  };
});
force.on('tick', function(){
  draw();
});
transition = function(sel, duration){
  if (duration > 0) {
    return sel.transition().duration(duration);
  } else {
    return sel;
  }
};
fadeOut = function(it, duration){
  return it.exit().remove().attr('class', null).transition().duration(duration).style('opacity', 0.01).remove();
};
draw = function(duration){
  var x$, y$, z$, z1$, w, z2$, z3$, z4$, z5$, l, z6$, z7$;
  x$ = d3.select('#edges').selectAll('.edge').data(edges);
  fadeOut(x$, duration);
  x$.enter().append('line').attr('class', 'edge');
  transition(x$).attr({
    x1: function(it){
      return it[0].x;
    },
    y1: function(it){
      return it[0].y;
    },
    x2: function(it){
      return it[1].x;
    },
    y2: function(it){
      return it[1].y;
    },
    'stroke-width': function(){
      return (function(it){
        return it * strokeScale;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  y$ = d3.select('#vertices').selectAll('.vertex').data(vertices);
  fadeOut(y$, duration);
  y$.enter().append('circle').attr('class', 'vertex').call(force.drag);
  transition(y$).attr({
    cx: function(it){
      return it.x;
    },
    cy: function(it){
      return it.y;
    },
    r: function(it){
      return 0.5 * strokeScale * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z$ = d3.select('#wedges').selectAll('.wedges').data(vertices);
  fadeOut(z$, duration);
  z1$ = z$.enter().append('g');
  z1$.attr('class', 'wedges');
  w = z$.selectAll('.wedge').data(function(it){
    var p, i$, ref$, len$, edge, j$, ref1$, len1$, player;
    p = [];
    for (i$ = 0, len$ = (ref$ = it.edges).length; i$ < len$; ++i$) {
      edge = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = users[edge] || 0).length; j$ < len1$; ++j$) {
        player = ref1$[j$];
        p.push({
          player: player,
          edge: edge
        });
      }
    }
    return p;
  }, function(it){
    return it.player + "" + it.edge;
  });
  z2$ = w;
  z2$.exit().transition().duration(duration).style('opacity', '0.01').remove();
  z3$ = z2$.enter().append('path');
  z3$.attr('class', 'wedge');
  z3$.style('opacity', 0.01);
  z3$.style('fill', function(){
    return playerColor(function(it){
      return it.player;
    }.apply(this, arguments));
  });
  transition(z2$, duration).attr('d', function(arg$, i, vertexId){
    var player, edge, vertex, cx, cy, r, line, angle, offsetStart, offsetEnd, x2, y2, sign, dSign, osx, osy, oex, oey, dx, dy, dr, D, t, term, sgn, isx, isy, iex, iey, ddx, ddy;
    player = arg$.player, edge = arg$.edge;
    vertex = vertices[vertexId];
    cx = vertex.x;
    cy = vertex.y;
    r = 0.5 * strokeScale * d3.max(vertex.edges, function(it){
      return it.bandwidth;
    });
    line = allocLine(state, users, player, edge);
    angle = line.angle, offsetStart = line.offsetStart, offsetEnd = line.offsetEnd;
    offsetStart -= edge.bandwidth / 2;
    offsetEnd -= edge.bandwidth / 2;
    offsetStart *= strokeScale;
    offsetEnd *= strokeScale;
    if (vertex === edge[0]) {
      x2 = edge[1].x;
      y2 = edge[1].y;
      sign = dSign = 1;
    } else {
      x2 = edge[0].x;
      y2 = edge[0].y;
      sign = dSign = -1;
    }
    osx = offsetStart * Math.sin(angle);
    osy = offsetStart * Math.cos(angle);
    oex = offsetEnd * Math.sin(angle);
    oey = offsetEnd * Math.cos(angle);
    dx = x2 - cx;
    dy = y2 - cy;
    dr = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    D = osx * (dy + osy) - (dx + osx) * osy;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    sgn = function(it){
      if (it < 0) {
        return -1;
      } else {
        return 1;
      }
    };
    sign *= angle > 0 ? -1 : 1;
    isx = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    isy = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    D = oex * (dy + oey) - (dx + oex) * oey;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    iex = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    iey = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    ddx = iex - isx;
    ddy = iey - isy;
    return "M " + cx + " " + cy + " l " + isx + " " + isy + " a " + r + " " + r + " 0 0 " + (dSign > 0 ? 1 : 0) + " " + ddx + " " + ddy + " Z";
  }).style('opacity', 1);
  z4$ = d3.select('#players').selectAll('.player').data(players);
  z4$.exit().remove();
  z5$ = z4$.enter().append('g');
  z5$.attr('id', function(it){
    return "player-" + it;
  });
  z5$.attr('class', 'player');
  z5$.style('stroke', playerColor);
  l = z4$.selectAll('.segment').data(function(player){
    return state.strategies[player].path.map(function(it){
      return {
        edge: it,
        line: allocLine(state, users, player, it)
      };
    });
  }, function(segment, i){
    return segment.edge + "" + i;
  });
  z6$ = l;
  z6$.exit().attr('class', null).transition().duration(duration).style('opacity', '0.01').remove();
  z7$ = z6$.enter().append('line').attr('class', 'segment');
  z7$.style('stroke-opacity', 0.01);
  transition(z6$, duration).attr({
    x1: function(it){
      return it.line.x1;
    },
    y1: function(it){
      return it.line.y1;
    },
    x2: function(it){
      return it.line.x2;
    },
    y2: function(it){
      return it.line.y2;
    },
    'stroke-width': function(d, i, j){
      return state.strategies[players[j]].bandwidth * strokeScale;
    }
  }).style('stroke-opacity', 1);
  z6$.classed('bottleneck', function(it){
    return it.bottleneck;
  });
};
force.start();
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}