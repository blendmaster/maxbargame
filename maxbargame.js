// Generated by LiveScript 1.2.0
var width, height, vertices, edges, topology, players, pathIdx, playerColor, paths, i$, len$, i, p, game, x$, strokeScale, force, idx, state, users, allocLine, selected, y$, svg, transition, fadeOut, identity, dragEdge, draw;
width = 500;
height = 500;
vertices = d3.range(9).map(function(){
  return new Vertex;
});
edges = function(it){
  return it.map(function(arg$){
    var s, t, b;
    s = arg$[0], t = arg$[1], b = arg$[2];
    return new Edge(vertices[s], vertices[t], b);
  });
}([[0, 1, 10], [1, 2, 7], [2, 3, 15], [3, 4, 5], [3, 6, 10], [6, 5, 9], [1, 6, 20], [1, 8, 10], [8, 7, 6], [6, 7, 5]]);
topology = {
  vertices: vertices,
  edges: edges
};
players = function(it){
  return it.map(function(arg$){
    var s, t;
    s = arg$[0], t = arg$[1];
    return new Player(vertices[s], vertices[t]);
  });
}([[0, 6], [8, 3], [5, 2]]);
pathIdx = function(it){
  return it.map(function(it){
    return it.map(function(it){
      return edges[it];
    });
  });
}([[0, 1, 2, 4], [8, 9, 4], [5, 4, 2]]);
playerColor = d3.scale.ordinal().range(colorbrewer.Dark2[8]);
paths = {};
for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
  i = i$;
  p = players[i$];
  paths[p] = pathIdx[i];
}
game = maxbargame(topology, players, allocate(topology, paths));
x$ = document.getElementById('scale');
strokeScale = parseFloat(x$.value);
x$.addEventListener('input', function(){
  strokeScale = parseFloat(this.value);
  draw();
});
force = d3.layout.force().size([width, height]).nodes(vertices).links(edges).linkDistance(100).charge(-500);
idx = 0;
state = game[idx];
users = {};
(function(){
  var player, ref$, strategy, i$, ref1$, len$, edge;
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
}.call(this));
document.getElementById('play-pause').addEventListener('click', function(){
  var player, ref$, strategy, i$, ref1$, len$, edge;
  idx++;
  if (game[idx] == null) {
    return;
  }
  state = game[idx];
  users = {};
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
  force.stop();
  draw(2000);
});
allocLine = curry$(function(state, users, player, edge){
  var strategy, ref$, x1, y1, x2, y2, offsetStart, i$, len$, u, b, offsetMid, offsetEnd, offset, angle, xOffset, yOffset;
  strategy = state.strategies[player];
  ref$ = edge[0], x1 = ref$.x, y1 = ref$.y;
  ref$ = edge[1], x2 = ref$.x, y2 = ref$.y;
  offsetStart = 0;
  for (i$ = 0, len$ = (ref$ = users[edge]).length; i$ < len$; ++i$) {
    u = ref$[i$];
    if (u === player + "") {
      break;
    }
    offsetStart += state.strategies[u].bandwidth;
  }
  b = strategy.bandwidth;
  offsetMid = offsetStart + b / 2;
  offsetEnd = offsetStart + b;
  offset = offsetMid - edge.bandwidth / 2;
  offset *= strokeScale;
  angle = Math.atan2(y1 - y2, x2 - x1);
  xOffset = offset * Math.sin(angle);
  yOffset = offset * Math.cos(angle);
  x1 += xOffset;
  x2 += xOffset;
  y1 += yOffset;
  y2 += yOffset;
  return {
    angle: angle,
    offsetStart: offsetStart,
    offsetEnd: offsetEnd,
    offset: offset,
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    bottleneck: edge === strategy.bottleneck
  };
});
y$ = svg = d3.select('#topology');
y$.on('click', function(){
  var v, ref$, x, y;
  if (d3.event.target === this) {
    if (d3.event.ctrlKey && selected != null) {
      v = new Vertex;
      ref$ = d3.mouse(this), x = ref$[0], y = ref$[1];
      v.x = x;
      v.y = y;
      vertices.push(v);
      edges.push(new Edge(v, selected, 10));
      force.start();
    } else {
      selected = void 8;
      draw();
    }
  }
});
force.on('tick', function(){
  draw();
});
transition = function(sel, duration){
  if (duration > 0) {
    return sel.transition().duration(duration);
  } else {
    return sel;
  }
};
fadeOut = function(it, duration){
  return it.exit().remove().attr('class', null).transition().duration(duration).style('opacity', 0.01).remove();
};
identity = function(it){
  return it;
};
dragEdge = d3.behavior.drag().on('dragstart', function(){
  force.stop();
}).on('drag', function(edge){
  var paths, p, ref$, strategy;
  edge.bandwidth -= d3.event.dy / strokeScale;
  edge.bandwidth = Math.max(1, edge.bandwidth);
  paths = {};
  for (p in ref$ = state.strategies) {
    strategy = ref$[p];
    paths[p] = strategy.path;
  }
  state = new State(allocate(topology, paths));
  draw();
}).on('dragend', function(){
  force.resume();
});
draw = function(duration){
  var x$, y$, z$, z1$, z2$, z3$, z4$, w, z5$, z6$, z7$, z8$, l, z9$, z10$;
  x$ = d3.select('#edges').selectAll('.edge').data(edges, identity);
  x$.exit().remove();
  x$.enter().append('line').attr('class', 'edge');
  transition(x$).attr({
    x1: function(it){
      return it[0].x;
    },
    y1: function(it){
      return it[0].y;
    },
    x2: function(it){
      return it[1].x;
    },
    y2: function(it){
      return it[1].y;
    },
    'stroke-width': function(){
      return (function(it){
        return it * strokeScale;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  y$ = d3.select('#edge-handles').selectAll('.edge-handle').data(edges, identity);
  y$.exit().remove();
  z$ = y$.enter().append('line').attr('class', 'edge-handle');
  z$.call(dragEdge);
  transition(y$).attr({
    x1: function(it){
      return it[0].x;
    },
    y1: function(it){
      return it[0].y;
    },
    x2: function(it){
      return it[1].x;
    },
    y2: function(it){
      return it[1].y;
    },
    'stroke-width': function(){
      return (function(it){
        return it * strokeScale;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  z1$ = d3.select('#vertices').selectAll('.vertex').data(vertices, identity);
  z1$.exit().remove();
  z1$.enter().append('circle').attr('class', 'vertex');
  z1$.classed('selected', (function(it){
    return it === selected;
  }));
  transition(z1$).attr({
    cx: function(it){
      return it.x;
    },
    cy: function(it){
      return it.y;
    },
    r: function(it){
      return 0.5 * strokeScale * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z2$ = d3.select('#handles').selectAll('.handle').data(vertices, identity);
  z2$.exit().remove();
  z2$.enter().append('circle').attr('class', 'handle').call(force.drag).on('click', function(vertex){
    var i$, x$, ref$, len$, y$;
    if (!d3.event.defaultPrevented) {
      if (d3.event.ctrlKey && selected != null) {
        if (vertex.srobhgien[selected] == null) {
          edges.push(new Edge(vertex, selected, 10));
          force.start();
        }
      } else if (d3.event.shiftKey) {
        if (!vertex.player && !vertex.edges.some(function(e){
          return users[e] != null;
        })) {
          if (connected(topology, vertex)) {
            vertices.splice(vertices.indexOf(vertex), 1);
            for (i$ = 0, len$ = (ref$ = vertex.edges).length; i$ < len$; ++i$) {
              x$ = ref$[i$];
              edges.splice(edges.indexOf(x$), 1);
            }
            for (i$ = 0, len$ = (ref$ = vertex.edges).length; i$ < len$; ++i$) {
              y$ = ref$[i$];
              if (vertex === y$[0]) {
                y$[1].edges.splice(y$[1].edges.indexOf(y$), 1);
                delete y$[1].neighbors[y$];
                delete y$[1].srobhgien[y$[0]];
              } else {
                y$[0].edges.splice(y$[0].edges.indexOf(y$), 0);
                delete y$[0].neighbors[y$];
                delete y$[0].srobhgien[y$[1]];
              }
            }
            force.start();
          }
        }
      } else {
        selected = vertex;
      }
    }
  });
  transition(z2$).attr({
    cx: function(it){
      return it.x;
    },
    cy: function(it){
      return it.y;
    },
    r: function(it){
      return 0.5 * strokeScale * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z3$ = d3.select('#wedges').selectAll('.wedges').data(vertices, identity);
  fadeOut(z3$, duration);
  z4$ = z3$.enter().append('g');
  z4$.attr('class', 'wedges');
  w = z3$.selectAll('.wedge').data(function(it){
    var p, i$, ref$, len$, edge, j$, ref1$, len1$, player;
    p = [];
    for (i$ = 0, len$ = (ref$ = it.edges).length; i$ < len$; ++i$) {
      edge = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = users[edge] || 0).length; j$ < len1$; ++j$) {
        player = ref1$[j$];
        p.push({
          player: player,
          edge: edge
        });
      }
    }
    return p;
  }, function(it){
    return it.player + "" + it.edge;
  });
  z5$ = w;
  z5$.exit().attr('class', null).transition().duration(duration).style('opacity', '0.01').remove();
  z6$ = z5$.enter().append('path');
  z6$.attr('class', 'wedge');
  z6$.style('opacity', 0.01);
  z6$.style('fill', function(){
    return playerColor(function(it){
      return it.player;
    }.apply(this, arguments));
  });
  transition(z5$, duration).attr('d', function(arg$, i, vertexId){
    var player, edge, vertex, cx, cy, r, line, angle, offsetStart, offsetEnd, x2, y2, sign, dSign, osx, osy, oex, oey, dx, dy, dr, D, t, term, sgn, isx, isy, iex, iey, ddx, ddy;
    player = arg$.player, edge = arg$.edge;
    vertex = vertices[vertexId];
    cx = vertex.x;
    cy = vertex.y;
    r = 0.5 * strokeScale * d3.max(vertex.edges, function(it){
      return it.bandwidth;
    });
    line = allocLine(state, users, player, edge);
    angle = line.angle, offsetStart = line.offsetStart, offsetEnd = line.offsetEnd;
    offsetStart -= edge.bandwidth / 2;
    offsetEnd -= edge.bandwidth / 2;
    offsetStart *= strokeScale;
    offsetEnd *= strokeScale;
    if (vertex === edge[0]) {
      x2 = edge[1].x;
      y2 = edge[1].y;
      sign = dSign = 1;
    } else {
      x2 = edge[0].x;
      y2 = edge[0].y;
      sign = dSign = -1;
    }
    osx = offsetStart * Math.sin(angle);
    osy = offsetStart * Math.cos(angle);
    oex = offsetEnd * Math.sin(angle);
    oey = offsetEnd * Math.cos(angle);
    dx = x2 - cx;
    dy = y2 - cy;
    dr = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    D = osx * (dy + osy) - (dx + osx) * osy;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    sgn = function(it){
      if (it < 0) {
        return -1;
      } else {
        return 1;
      }
    };
    sign *= angle > 0 ? -1 : 1;
    isx = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    isy = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    D = oex * (dy + oey) - (dx + oex) * oey;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    iex = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    iey = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    ddx = iex - isx;
    ddy = iey - isy;
    return "M " + cx + " " + cy + " l " + isx + " " + isy + " a " + r + " " + r + " 0 0 " + (dSign > 0 ? 1 : 0) + " " + ddx + " " + ddy + " Z";
  }).style('opacity', 1);
  z7$ = d3.select('#players').selectAll('.player').data(players, identity);
  z7$.exit().remove();
  z8$ = z7$.enter().append('g');
  z8$.attr('id', function(it){
    return "player-" + it;
  });
  z8$.attr('class', 'player');
  z8$.style('stroke', playerColor);
  l = z7$.selectAll('.segment').data(function(player){
    return state.strategies[player].path.map(function(it){
      return {
        edge: it,
        line: allocLine(state, users, player, it)
      };
    });
  }, function(segment, i){
    return segment.edge + "" + i;
  });
  z9$ = l;
  z9$.exit().attr('class', null).transition().duration(duration).style('opacity', '0.01').remove();
  z10$ = z9$.enter().append('line').attr('class', 'segment');
  z10$.style('stroke-opacity', 0.01);
  transition(z9$, duration).attr({
    x1: function(it){
      return it.line.x1;
    },
    y1: function(it){
      return it.line.y1;
    },
    x2: function(it){
      return it.line.x2;
    },
    y2: function(it){
      return it.line.y2;
    },
    'stroke-width': function(d, i, j){
      return state.strategies[players[j]].bandwidth * strokeScale;
    }
  }).style('stroke-opacity', 1);
  z9$.classed('bottleneck', function(it){
    return it.line.bottleneck;
  });
};
force.start();
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}