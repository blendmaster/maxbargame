// Generated by LiveScript 1.2.0
var width, height, vertices, edges, topology, players, pathIdx, playerColor, paths, i$, len$, i, p, users, currentPlayer, playerIdx, state, states, playing, sames, randomize, init, x$, y$, strokeScale, z$, forceEnabled, $, z1$, edgeLength, z2$, edgeStrength, z3$, charges, z4$, chargeScale, force, step, autoPlay, speed, z5$, pp, allocLine, selected, z6$, svg, transition, fadeOut, identity, dragEdge, draw;
width = document.documentElement.clientWidth - 50;
height = 500;
vertices = d3.range(9).map(function(){
  return new Vertex;
});
edges = function(it){
  return it.map(function(arg$){
    var s, t, b;
    s = arg$[0], t = arg$[1], b = arg$[2];
    return new Edge(vertices[s], vertices[t], b);
  });
}([[0, 1, 10], [1, 2, 7], [2, 3, 15], [3, 4, 5], [3, 6, 10], [6, 5, 9], [1, 6, 20], [1, 8, 10], [8, 7, 6], [6, 7, 5]]);
topology = {
  vertices: vertices,
  edges: edges
};
players = function(it){
  return it.map(function(arg$){
    var s, t;
    s = arg$[0], t = arg$[1];
    return new Player(vertices[s], vertices[t]);
  });
}([[0, 6], [8, 3], [5, 2]]);
pathIdx = function(it){
  return it.map(function(it){
    return it.map(function(it){
      return edges[it];
    });
  });
}([[0, 1, 2, 4], [8, 9, 4], [5, 4, 2]]);
playerColor = d3.scale.category20();
paths = {};
for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
  i = i$;
  p = players[i$];
  paths[p] = pathIdx[i];
}
playing = false;
sames = 0;
randomize = function(){
  var numPlayers, numVertices, edgeProb, ref$;
  numPlayers = parseInt(document.getElementById('num-players').value, 10);
  numVertices = parseInt(document.getElementById('num-vertices').value, 10);
  edgeProb = parseFloat(
  document.getElementById('edge-prob').value);
  ref$ = randomTopology(numPlayers, numVertices, edgeProb), vertices = ref$.vertices, edges = ref$.edges, players = ref$.players, paths = ref$.paths;
  topology = {
    vertices: vertices,
    edges: edges
  };
};
init = function(){
  var player, ref$, strategy, i$, ref1$, len$, edge;
  playing = false;
  sames = 0;
  currentPlayer = players[0];
  playerIdx = 0;
  state = new State(allocate(topology, paths), currentPlayer);
  users = {};
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
  states = [state];
};
init();
x$ = document.getElementById('randomize');
x$.addEventListener('click', function(){
  randomize();
  init();
  force.nodes(vertices);
  force.links(edges);
  force.start();
});
y$ = document.getElementById('scale');
strokeScale = parseFloat(y$.value);
y$.addEventListener('input', function(){
  strokeScale = parseFloat(this.value);
  if (forceEnabled) {
    force.start();
  }
  draw();
});
z$ = document.getElementById('force-enabled');
forceEnabled = z$.checked;
z$.addEventListener('change', function(){
  var i$, ref$, len$, v;
  forceEnabled = this.checked;
  if (forceEnabled) {
    for (i$ = 0, len$ = (ref$ = vertices).length; i$ < len$; ++i$) {
      v = ref$[i$];
      v.fixed = false;
    }
    force.resume();
  } else {
    for (i$ = 0, len$ = (ref$ = vertices).length; i$ < len$; ++i$) {
      v = ref$[i$];
      v.fixed = true;
    }
    force.stop();
  }
});
$ = bind$(document, 'getElementById');
z1$ = $('edge-length');
edgeLength = parseInt(z1$.value, 10);
z1$.addEventListener('input', function(){
  edgeLength = parseInt(z1$.value, 10);
  force.start();
});
z2$ = $('edge-strength');
edgeStrength = parseFloat(z2$.value);
z2$.addEventListener('input', function(){
  edgeStrength = parseFloat(z2$.value);
  force.start();
});
z3$ = $('charges');
charges = parseFloat(z3$.value);
z3$.addEventListener('input', function(){
  charges = parseFloat(z3$.value);
  force.start();
});
z4$ = $('charge-scale');
chargeScale = parseFloat(z4$.value);
z4$.addEventListener('input', function(){
  chargeScale = parseFloat(z4$.value);
  force.start();
});
force = d3.layout.force().size([width, height]).nodes(vertices).links(edges).linkDistance(function(it){
  return edgeLength / it.bandwidth;
}).linkStrength(function(it){
  return edgeStrength * it.bandwidth / d3.max(edges, function(it){
    return it.bandwidth;
  });
}).charge(function(it){
  return -charges - chargeScale * d3.sum(it.edges, function(it){
    var ref$;
    return ((ref$ = users[it]) != null ? ref$.length : void 8) || 0;
  });
});
document.getElementById('step').addEventListener('click', function(){
  step();
});
step = function(auto){
  var ref$, nextState, better, player, strategy, i$, ref1$, len$, edge;
  auto == null && (auto = false);
  d3.selectAll('.dead').remove();
  ref$ = maxbargame(topology, players, state.strategies, currentPlayer), nextState = ref$.state, better = ref$.better;
  playerIdx = (1 + playerIdx) % players.length;
  currentPlayer = players[playerIdx];
  nextState.player = currentPlayer;
  states.push(nextState);
  state = nextState;
  users = {};
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(player);
    }
  }
  force.stop();
  draw(auto ? 0 : 2000);
  return better;
};
autoPlay = function(){
  var better;
  if (playerIdx === players.length) {
    sames = 0;
  }
  better = step(true);
  if (!better) {
    sames++;
  }
  if (sames >= players.length) {
    playing = false;
    pp.textContent = 'play';
  }
  if (playing) {
    setTimeout(autoPlay, speed);
  }
};
speed = 250;
z5$ = pp = document.getElementById('play-pause');
z5$.addEventListener('click', function(){
  if (playing) {
    playing = false;
    this.textContent = 'play';
  } else {
    sames = 0;
    playing = true;
    this.textContent = 'pause';
    autoPlay();
  }
});
allocLine = curry$(function(state, users, player, edge){
  var strategy, ref$, x1, y1, x2, y2, offsetStart, i$, len$, u, b, offsetMid, offsetEnd, offset, angle, xOffset, yOffset;
  strategy = state.strategies[player];
  ref$ = edge[0], x1 = ref$.x, y1 = ref$.y;
  ref$ = edge[1], x2 = ref$.x, y2 = ref$.y;
  offsetStart = 0;
  for (i$ = 0, len$ = (ref$ = users[edge]).length; i$ < len$; ++i$) {
    u = ref$[i$];
    if (u === player + "") {
      break;
    }
    offsetStart += state.strategies[u].bandwidth;
  }
  b = strategy.bandwidth;
  offsetMid = offsetStart + b / 2;
  offsetEnd = offsetStart + b;
  offset = offsetMid - edge.bandwidth / 2;
  offset *= strokeScale;
  angle = Math.atan2(y1 - y2, x2 - x1);
  xOffset = offset * Math.sin(angle);
  yOffset = offset * Math.cos(angle);
  x1 += xOffset;
  x2 += xOffset;
  y1 += yOffset;
  y2 += yOffset;
  return {
    angle: angle,
    offsetStart: offsetStart,
    offsetEnd: offsetEnd,
    offset: offset,
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    bottleneck: edge === strategy.bottleneck
  };
});
z6$ = svg = d3.select('#topology');
z6$.attr({
  width: width,
  height: height
});
z6$.on('click', function(){
  var v, ref$, x, y;
  if (d3.event.target === this) {
    if (d3.event.ctrlKey && selected != null) {
      v = new Vertex;
      ref$ = d3.mouse(this), x = ref$[0], y = ref$[1];
      v.x = x;
      v.y = y;
      vertices.push(v);
      edges.push(new Edge(v, selected, 10));
      force.start();
    } else {
      selected = void 8;
      draw();
    }
  }
});
force.on('tick', function(){
  if (!forceEnabled) {
    force.stop();
  }
  draw();
});
transition = function(sel, duration){
  if (duration > 0) {
    return sel.transition().duration(duration);
  } else {
    return sel;
  }
};
fadeOut = function(it, duration){
  return it.exit().remove().attr('class', 'dead').transition().duration(duration).style('opacity', 0.01).remove();
};
identity = function(it){
  return it;
};
dragEdge = d3.behavior.drag().on('dragstart', function(){
  force.stop();
}).on('drag', function(edge){
  var paths, p, ref$, strategy;
  edge.bandwidth -= d3.event.dy / strokeScale;
  edge.bandwidth = Math.max(1, edge.bandwidth);
  paths = {};
  for (p in ref$ = state.strategies) {
    strategy = ref$[p];
    paths[p] = strategy.path;
  }
  state = new State(allocate(topology, paths), currentPlayer);
  states[states.length - 1] = state;
  draw();
}).on('dragend', function(){
  force.start();
});
draw = function(duration){
  var x$, y$, z$, z1$, z2$, z3$, z4$, w, z5$, z6$, z7$, z8$, l, z9$, z10$, rowHeight, rowWidth, maxBandwidth, bScale, z11$, z12$, s, z13$, z14$, z15$, z16$, z17$, z18$;
  x$ = d3.select('#edges').selectAll('.edge').data(edges, identity);
  x$.exit().remove();
  x$.enter().append('line').attr('class', 'edge');
  transition(x$).attr({
    x1: function(it){
      return it[0].x;
    },
    y1: function(it){
      return it[0].y;
    },
    x2: function(it){
      return it[1].x;
    },
    y2: function(it){
      return it[1].y;
    },
    'stroke-width': function(){
      return (function(it){
        return it * strokeScale;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  y$ = d3.select('#edge-handles').selectAll('.edge-handle').data(edges, identity);
  y$.exit().remove();
  z$ = y$.enter().append('line').attr('class', 'edge-handle');
  z$.call(dragEdge);
  transition(y$).attr({
    x1: function(it){
      return it[0].x;
    },
    y1: function(it){
      return it[0].y;
    },
    x2: function(it){
      return it[1].x;
    },
    y2: function(it){
      return it[1].y;
    },
    'stroke-width': function(){
      return (function(it){
        return it * strokeScale;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  z1$ = d3.select('#vertices').selectAll('.vertex').data(vertices, identity);
  z1$.exit().remove();
  z1$.enter().append('circle').attr('class', 'vertex');
  z1$.classed('selected', (function(it){
    return it === selected;
  }));
  transition(z1$).attr({
    cx: function(it){
      return it.x;
    },
    cy: function(it){
      return it.y;
    },
    r: function(it){
      return 0.5 * strokeScale * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z2$ = d3.select('#handles').selectAll('.handle').data(vertices, identity);
  z2$.exit().remove();
  z2$.enter().append('circle').attr('class', 'handle').call(force.drag).on('click', function(vertex){
    var i$, x$, ref$, len$, y$;
    if (!d3.event.defaultPrevented) {
      if (d3.event.ctrlKey && selected != null) {
        if (vertex.srobhgien[selected] == null) {
          edges.push(new Edge(vertex, selected, 10));
          force.start();
        }
      } else if (d3.event.shiftKey) {
        if (!vertex.player && !vertex.edges.some(function(e){
          return users[e] != null;
        })) {
          if (connected(topology, vertex)) {
            vertices.splice(vertices.indexOf(vertex), 1);
            for (i$ = 0, len$ = (ref$ = vertex.edges).length; i$ < len$; ++i$) {
              x$ = ref$[i$];
              edges.splice(edges.indexOf(x$), 1);
            }
            for (i$ = 0, len$ = (ref$ = vertex.edges).length; i$ < len$; ++i$) {
              y$ = ref$[i$];
              if (vertex === y$[0]) {
                y$[1].edges.splice(y$[1].edges.indexOf(y$), 1);
                delete y$[1].neighbors[y$];
                delete y$[1].srobhgien[y$[0]];
              } else {
                y$[0].edges.splice(y$[0].edges.indexOf(y$), 0);
                delete y$[0].neighbors[y$];
                delete y$[0].srobhgien[y$[1]];
              }
            }
            force.start();
          }
        }
      } else {
        selected = vertex;
      }
    }
  });
  transition(z2$).attr({
    cx: function(it){
      return it.x;
    },
    cy: function(it){
      return it.y;
    },
    r: function(it){
      return 0.5 * strokeScale * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z3$ = d3.select('#wedges').selectAll('.wedges').data(vertices, identity);
  fadeOut(z3$, duration);
  z4$ = z3$.enter().append('g');
  z4$.attr('class', 'wedges');
  w = z3$.selectAll('.wedge').data(function(it){
    var p, i$, ref$, len$, edge, j$, ref1$, len1$, player;
    p = [];
    for (i$ = 0, len$ = (ref$ = it.edges).length; i$ < len$; ++i$) {
      edge = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = users[edge] || 0).length; j$ < len1$; ++j$) {
        player = ref1$[j$];
        p.push({
          player: player,
          edge: edge
        });
      }
    }
    return p;
  }, function(it){
    return it.player + "" + it.edge;
  });
  z5$ = w;
  z5$.exit().attr('class', null).transition().duration(duration).style('opacity', '0.01').remove();
  z6$ = z5$.enter().append('path');
  z6$.attr('class', 'wedge');
  z6$.style('opacity', 0.01);
  z6$.style('fill', function(){
    return playerColor(function(it){
      return it.player;
    }.apply(this, arguments));
  });
  transition(z5$, duration).attr('d', function(arg$, i, vertexId){
    var player, edge, vertex, cx, cy, r, line, angle, offsetStart, offsetEnd, x2, y2, sign, dSign, osx, osy, oex, oey, dx, dy, dr, D, t, term, sgn, isx, isy, iex, iey, ddx, ddy;
    player = arg$.player, edge = arg$.edge;
    vertex = vertices[vertexId];
    cx = vertex.x;
    cy = vertex.y;
    r = 0.5 * strokeScale * d3.max(vertex.edges, function(it){
      return it.bandwidth;
    });
    line = allocLine(state, users, player, edge);
    angle = line.angle, offsetStart = line.offsetStart, offsetEnd = line.offsetEnd;
    offsetStart -= edge.bandwidth / 2;
    offsetEnd -= edge.bandwidth / 2;
    offsetStart *= strokeScale;
    offsetEnd *= strokeScale;
    if (vertex === edge[0]) {
      x2 = edge[1].x;
      y2 = edge[1].y;
      sign = dSign = 1;
    } else {
      x2 = edge[0].x;
      y2 = edge[0].y;
      sign = dSign = -1;
    }
    osx = offsetStart * Math.sin(angle);
    osy = offsetStart * Math.cos(angle);
    oex = offsetEnd * Math.sin(angle);
    oey = offsetEnd * Math.cos(angle);
    dx = x2 - cx;
    dy = y2 - cy;
    dr = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    D = osx * (dy + osy) - (dx + osx) * osy;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    sgn = function(it){
      if (it < 0) {
        return -1;
      } else {
        return 1;
      }
    };
    sign *= angle > 0 ? -1 : 1;
    isx = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    isy = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    D = oex * (dy + oey) - (dx + oex) * oey;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    iex = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    iey = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    ddx = iex - isx;
    ddy = iey - isy;
    return "M " + cx + " " + cy + " l " + isx + " " + isy + " a " + r + " " + r + " 0 0 " + (dSign > 0 ? 1 : 0) + " " + ddx + " " + ddy + " Z";
  }).style('opacity', 1);
  z7$ = d3.select('#players').selectAll('.player').data(players, identity);
  z7$.exit().remove();
  z8$ = z7$.enter().append('g');
  z8$.attr('id', function(it){
    return "player-" + it;
  });
  z8$.attr('class', 'player');
  z8$.style('stroke', playerColor);
  l = z7$.selectAll('.segment').data(function(player){
    return state.strategies[player].path.map(function(it){
      return {
        edge: it,
        line: allocLine(state, users, player, it)
      };
    });
  }, function(segment, i){
    return segment.edge + "" + i;
  });
  z9$ = l;
  z9$.exit().attr('class', null).transition().duration(duration).style('opacity', '0.01').remove();
  z10$ = z9$.enter().append('line').attr('class', 'segment');
  z10$.style('stroke-opacity', 0.01);
  transition(z9$, duration).attr({
    x1: function(it){
      return it.line.x1;
    },
    y1: function(it){
      return it.line.y1;
    },
    x2: function(it){
      return it.line.x2;
    },
    y2: function(it){
      return it.line.y2;
    },
    'stroke-width': function(d, i, j){
      return state.strategies[players[j]].bandwidth * strokeScale;
    }
  }).style('stroke-opacity', 1);
  z9$.classed('bottleneck', function(it){
    return it.line.bottleneck;
  });
  rowHeight = 15;
  rowWidth = 100 / players.length;
  maxBandwidth = d3.max(edges, function(it){
    return it.bandwidth;
  });
  bScale = d3.scale.linear().domain([0, maxBandwidth]).range([0, rowHeight]);
  z11$ = d3.select('#states');
  z11$.attr('height', (players.length + 2) * rowHeight);
  z11$.attr('width', 2 * rowHeight + states.length * rowWidth);
  z12$ = z11$.selectAll('.player-row').data(players, identity);
  z12$.exit().remove();
  z12$.enter().append('g').attr('id', function(it){
    return "player-row-" + it;
  }).attr('class', 'player-row').attr('transform', function(it, i){
    return "translate(0, " + i * rowHeight + ")";
  }).append('rect').attr({
    'class': 'icon',
    x: 0,
    y: 0,
    width: rowHeight,
    height: rowHeight,
    fill: playerColor
  });
  s = z12$.selectAll('.state').data(function(player){
    return states.map(function(state){
      return {
        id: state.id,
        player: state.player,
        strategy: state.strategies[player]
      };
    });
  }, function(it){
    return it.id;
  });
  z13$ = s;
  z13$.exit().remove();
  z14$ = z13$.enter().append('g');
  z14$.attr({
    'class': 'state'
  });
  z14$.append('rect').attr({
    'class': 'bg',
    x: function(it, i){
      return 2 * rowHeight + i * rowWidth;
    },
    height: rowHeight,
    width: rowWidth,
    fill: function(it, i, j){
      if (it.player === players[j]) {
        return '#eee';
      } else {
        return 'transparent';
      }
    }
  });
  z14$.append('rect').attr({
    'class': 'fg',
    x: function(it, i){
      return 2 * rowHeight + i * rowWidth;
    },
    width: rowWidth,
    fill: function(it, i, j){
      if (it.player === players[j]) {
        return playerColor(it.player);
      } else {
        return '#aaa';
      }
    }
  });
  z15$ = z13$.select('.fg');
  z15$.attr('y', function(it){
    return rowHeight - bScale(it.strategy.bandwidth);
  });
  z15$.attr('height', function(it){
    return bScale(it.strategy.bandwidth);
  });
  z16$ = d3.select('#total');
  z16$.attr('transform', "translate(0, " + rowHeight * (1 + players.length) + ")");
  s = z16$.selectAll('.sum').data(states.map(function(it){
    var sum, p, ref$, strategy;
    sum = 0;
    for (p in ref$ = it.strategies) {
      strategy = ref$[p];
      sum += strategy.bandwidth;
    }
    return sum;
  }));
  z17$ = s;
  z17$.exit().remove();
  z18$ = z17$.enter().append('rect');
  z18$.attr('class', 'sum');
  z17$.attr({
    height: function(it){
      return bScale(it / players.length);
    },
    x: function(it, i){
      return 2 * rowHeight + i * rowWidth;
    },
    width: rowWidth,
    y: function(it){
      return rowHeight - bScale(it / players.length);
    }
  });
};
force.start();
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}