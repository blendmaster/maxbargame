// Generated by LiveScript 1.2.0
var Node, Edge, Player, PlayerState, nodes, edges, players, game, x, y, drag, draw;
Node = (function(){
  Node.displayName = 'Node';
  var prototype = Node.prototype, constructor = Node;
  function Node(id, x, y){
    this.id = id;
    this.x = x;
    this.y = y;
    this.neighbors = [];
    this.edges = [];
    this.player = void 8;
  }
  return Node;
}());
Edge = (function(){
  Edge.displayName = 'Edge';
  var prototype = Edge.prototype, constructor = Edge;
  function Edge(id, source, target, bandwidth){
    this.id = id;
    this.source = source;
    this.target = target;
    this.bandwidth = bandwidth;
    this.source.neighbors.push(this.target);
    this.target.neighbors.push(this.source);
    this.source.edges.push(this);
    this.target.edges.push(this);
  }
  return Edge;
}());
Player = (function(){
  Player.displayName = 'Player';
  var prototype = Player.prototype, constructor = Player;
  function Player(id, source, target){
    this.id = id;
    this.source = source;
    this.target = target;
    this.source.player = this;
    this.target.player = this;
  }
  return Player;
}());
PlayerState = (function(){
  PlayerState.displayName = 'PlayerState';
  var prototype = PlayerState.prototype, constructor = PlayerState;
  function PlayerState(path, bottleneck, bandwidth, diff){
    this.path = path;
    this.bottleneck = bottleneck;
    this.bandwidth = bandwidth;
    this.diff = diff;
  }
  return PlayerState;
}());
nodes = function(it){
  return it.map(function(arg$, i){
    var x, y;
    x = arg$[0], y = arg$[1];
    return new Node(i, x, y);
  });
}([[50, 10], [45, 40], [70, 30], [75, 50], [90, 60], [80, 90], [40, 85], [30, 90], [10, 50]]);
edges = function(it){
  return it.map(function(arg$, i){
    var s, t, b;
    s = arg$[0], t = arg$[1], b = arg$[2];
    return new Edge(i, nodes[s], nodes[t], b);
  });
}([[0, 1, 10], [1, 2, 5], [2, 3, 15], [3, 4, 5], [3, 6, 10], [6, 5, 9], [1, 6, 4], [1, 8, 10], [8, 7, 6], [6, 7, 5]]);
players = function(it){
  return it.map(function(arg$, i){
    var s, t;
    s = arg$[0], t = arg$[1];
    return new Player(i, nodes[s], nodes[t]);
  });
}([[0, 4], [8, 3], [5, 2]]);
game = initialize(nodes, edges, players);
function initialize(nodes, edges, players){
  var paths, finalUtilization, utilization, i$, len$, edge, u, fu, j$, len1$, i, path, player, k$, len2$, e, playerBandwidth, res$, x$, undetermined, residuals, bottlenecks, y$, globalBottleneck, b, fair;
  paths = function(it){
    return it.map(function(it){
      return it.map(function(it){
        return edges[it];
      });
    });
  }([[0, 1, 2, 3], [8, 9, 4], [5, 4, 2]]);
  finalUtilization = [];
  utilization = [];
  for (i$ = 0, len$ = edges.length; i$ < len$; ++i$) {
    edge = edges[i$];
    utilization.push(u = new Set);
    finalUtilization.push(fu = []);
    for (j$ = 0, len1$ = paths.length; j$ < len1$; ++j$) {
      i = j$;
      path = paths[j$];
      player = players[i];
      for (k$ = 0, len2$ = path.length; k$ < len2$; ++k$) {
        e = path[k$];
        if (e === edge) {
          u.add(player);
          fu.push(player);
        }
      }
    }
  }
  res$ = [];
  for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
    x$ = players[i$];
    res$.push(0);
  }
  playerBandwidth = res$;
  undetermined = new Set(players);
  residuals = edges.map(function(it){
    return it.bandwidth;
  });
  res$ = [];
  for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
    y$ = players[i$];
    res$.push(void 8);
  }
  bottlenecks = res$;
  while (undetermined.size > 0) {
    globalBottleneck = leastEqualShare(utilization, residuals);
    u = utilization[globalBottleneck];
    b = residuals[globalBottleneck];
    fair = b / u.size;
    u.forEach(fn$);
  }
  return {
    utilization: finalUtilization,
    players: players.map(function(player, i){
      return new PlayerState(paths[i], bottlenecks[i], playerBandwidth[i], 0);
    })
  };
  function fn$(player){
    var i$, ref$, len$, edge;
    playerBandwidth[player.id] = fair;
    bottlenecks[player.id] = edges[globalBottleneck];
    for (i$ = 0, len$ = (ref$ = paths[player.id]).length; i$ < len$; ++i$) {
      edge = ref$[i$];
      residuals[edge.id] -= fair;
      utilization[edge.id]['delete'](player);
    }
    undetermined['delete'](player);
  }
}
function leastEqualShare(utilization, residuals){
  var min, minEquality, i$, to$, i, u, b, equality;
  min = void 8;
  minEquality = Infinity;
  for (i$ = 0, to$ = utilization.length; i$ < to$; ++i$) {
    i = i$;
    u = utilization[i].size;
    if (!(u > 0)) {
      continue;
    }
    b = residuals[i];
    equality = b / u;
    if (equality < minEquality) {
      minEquality = equality;
      min = i;
    }
  }
  return min;
}
x = d3.scale.linear().domain([0, 100]).range([0, 500]);
y = d3.scale.linear().domain([0, 100]).range([0, 500]);
drag = d3.behavior.drag().on('drag', function(it){
  it.x += x.invert(d3.event.dx);
  it.y += y.invert(d3.event.dy);
  draw();
});
draw = function(){
  var x$, y$, z$, z1$;
  x$ = d3.select('#edges').selectAll('.edge').data(edges);
  x$.enter().append('line').attr('class', 'edge');
  x$.attr({
    x1: function(){
      return x(function(it){
        return it.source.x;
      }.apply(this, arguments));
    },
    y1: function(){
      return y(function(it){
        return it.source.y;
      }.apply(this, arguments));
    },
    x2: function(){
      return x(function(it){
        return it.target.x;
      }.apply(this, arguments));
    },
    y2: function(){
      return y(function(it){
        return it.target.y;
      }.apply(this, arguments));
    },
    'stroke-width': function(){
      return (function(it){
        return it * 4;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  y$ = d3.select('#nodes').selectAll('.node').data(nodes);
  y$.enter().append('circle').attr('class', function(it){
    var that;
    return "node " + ((that = it.player) ? "player-" + that.id : '');
  }).call(drag).on('mouseenter', function(it){
    var that;
    if ((that = it.player) != null) {
      d3.select("#player-" + that.id).classed('hover', true);
      d3.select('#topology').classed('dim', true);
    }
  }).on('mouseleave', function(it){
    var that;
    if ((that = it.player) != null) {
      d3.select("#player-" + that.id).classed('hover', false);
      d3.select('#topology').classed('dim', false);
    }
  });
  y$.attr({
    cx: function(){
      return x(function(it){
        return it.x;
      }.apply(this, arguments));
    },
    cy: function(){
      return y(function(it){
        return it.y;
      }.apply(this, arguments));
    },
    r: function(it){
      return 2 * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z$ = d3.select('#players').selectAll('.player').data(players);
  z1$ = z$.enter().append('g');
  z1$.attr('class', 'player');
  z1$.attr('id', function(it){
    return "player-" + it.id;
  });
  z1$.append('g').attr('class', 'path');
  z$.select('.path').each(function(player){
    var s, line, x$;
    s = game.players[player.id];
    line = s.path.map(function(it){
      var x1, x2, y1, y2, utilization, offsetStart, i$, len$, u, b, offset, angle, xOffset, yOffset;
      x1 = x(it.source.x);
      x2 = x(it.target.x);
      y1 = y(it.source.y);
      y2 = y(it.target.y);
      utilization = game.utilization[it.id].slice();
      offsetStart = 0;
      for (i$ = 0, len$ = utilization.length; i$ < len$; ++i$) {
        u = utilization[i$];
        if (u === player) {
          break;
        }
        offsetStart += game.players[u.id].bandwidth;
      }
      b = game.players[player.id].bandwidth;
      offsetStart = offsetStart + b / 2;
      offset = offsetStart - it.bandwidth / 2;
      offset *= 4;
      angle = Math.atan2(y1 - y2, x2 - x1);
      xOffset = offset * Math.sin(angle);
      yOffset = offset * Math.cos(angle);
      x1 += xOffset;
      x2 += xOffset;
      y1 += yOffset;
      y2 += yOffset;
      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        bottleneck: it === s.bottleneck
      };
    });
    x$ = d3.select(this).selectAll('.segment').data(line);
    x$.enter().append('line').attr('class', 'segment');
    x$.attr({
      x1: function(it){
        return it.x1;
      },
      y1: function(it){
        return it.y1;
      },
      x2: function(it){
        return it.x2;
      },
      y2: function(it){
        return it.y2;
      },
      'stroke-width': game.players[player.id].bandwidth * 4
    }).classed('bottleneck', function(it){
      return it.bottleneck;
    });
    return x$;
  });
};
draw();