// Generated by LiveScript 1.2.0
var vertices, edges, topology, players, paths, game, x, y, drag, idx, allocLine, draw;
vertices = function(it){
  return it.map(function(arg$, i){
    var x, y;
    x = arg$[0], y = arg$[1];
    return new Vertex(i, x, y);
  });
}([[50, 10], [45, 40], [70, 30], [75, 50], [90, 60], [80, 90], [40, 85], [30, 90], [10, 50]]);
edges = function(it){
  return it.map(function(arg$, i){
    var s, t, b;
    s = arg$[0], t = arg$[1], b = arg$[2];
    return new Edge(i, vertices[s], vertices[t], b);
  });
}([[0, 1, 10], [1, 2, 7], [2, 3, 15], [3, 4, 5], [3, 6, 10], [6, 5, 9], [1, 6, 20], [1, 8, 10], [8, 7, 6], [6, 7, 5]]);
topology = {
  vertices: vertices,
  edges: edges
};
players = function(it){
  return it.map(function(arg$, i){
    var s, t;
    s = arg$[0], t = arg$[1];
    return new Player(i, vertices[s], vertices[t]);
  });
}([[0, 6], [8, 3], [5, 2]]);
paths = function(it){
  return it.map(function(it){
    return it.map(function(it){
      return edges[it];
    });
  });
}([[0, 1, 2, 4], [8, 9, 4], [5, 4, 2]]);
game = maxbargame(topology, players, allocate(topology, paths));
x = d3.scale.linear().domain([0, 100]).range([0, 500]);
y = d3.scale.linear().domain([0, 100]).range([0, 500]);
drag = d3.behavior.drag().on('drag', function(it){
  it.x += x.invert(d3.event.dx);
  it.y += y.invert(d3.event.dy);
  draw();
});
idx = 0;
document.getElementById('play-pause').addEventListener('click', function(){
  idx++;
  draw();
});
allocLine = curry$(function(state, users, player, edge){
  var strategy, x1, x2, y1, y2, offsetStart, i$, ref$, len$, u, b, offsetMid, offsetEnd, offset, angle, xOffset, yOffset;
  strategy = state.strategies[player];
  x1 = x(edge[0].x);
  x2 = x(edge[1].x);
  y1 = y(edge[0].y);
  y2 = y(edge[1].y);
  offsetStart = 0;
  for (i$ = 0, len$ = (ref$ = users[edge]).length; i$ < len$; ++i$) {
    u = ref$[i$];
    if (u === player) {
      break;
    }
    offsetStart += state.strategies[u].bandwidth;
  }
  b = strategy.bandwidth;
  offsetMid = offsetStart + b / 2;
  offsetEnd = offsetStart + b;
  offset = offsetMid - edge.bandwidth / 2;
  offset *= 4;
  angle = Math.atan2(y1 - y2, x2 - x1);
  xOffset = offset * Math.sin(angle);
  yOffset = offset * Math.cos(angle);
  x1 += xOffset;
  x2 += xOffset;
  y1 += yOffset;
  y2 += yOffset;
  return {
    angle: angle,
    offsetStart: offsetStart,
    offsetEnd: offsetEnd,
    offset: offset,
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    bottleneck: edge === strategy.bottleneck
  };
});
draw = function(){
  var state, users, player, ref$, strategy, i$, ref1$, len$, edge, x$, y$, z$, z1$, w, z2$, z3$, z4$;
  state = game[idx];
  users = {};
  for (player in ref$ = state.strategies) {
    strategy = ref$[player];
    for (i$ = 0, len$ = (ref1$ = strategy.path).length; i$ < len$; ++i$) {
      edge = ref1$[i$];
      (users[edge] || (users[edge] = [])).push(players[player]);
    }
  }
  x$ = d3.select('#edges').selectAll('.edge').data(edges);
  x$.exit().remove();
  x$.enter().append('line').attr('class', 'edge');
  x$.attr({
    x1: function(){
      return x(function(it){
        return it[0].x;
      }.apply(this, arguments));
    },
    y1: function(){
      return y(function(it){
        return it[0].y;
      }.apply(this, arguments));
    },
    x2: function(){
      return x(function(it){
        return it[1].x;
      }.apply(this, arguments));
    },
    y2: function(){
      return y(function(it){
        return it[1].y;
      }.apply(this, arguments));
    },
    'stroke-width': function(){
      return (function(it){
        return it * 4;
      })(function(it){
        return it.bandwidth;
      }.apply(this, arguments));
    }
  });
  y$ = d3.select('#vertices').selectAll('.vertex').data(vertices);
  y$.exit().remove();
  y$.enter().append('circle').attr('class', 'vertex').call(drag).on('mouseenter', function(it){
    var that;
    if ((that = it.player) != null) {
      d3.select("#player-" + that).classed('hover', true);
      d3.select('#topology').classed('dim', true);
    }
  }).on('mouseleave', function(it){
    var that;
    if ((that = it.player) != null) {
      d3.select("#player-" + that).classed('hover', false);
      d3.select('#topology').classed('dim', false);
    }
  });
  y$.attr({
    cx: function(){
      return x(function(it){
        return it.x;
      }.apply(this, arguments));
    },
    cy: function(){
      return y(function(it){
        return it.y;
      }.apply(this, arguments));
    },
    r: function(it){
      return 2 * d3.max(it.edges, function(it){
        return it.bandwidth;
      });
    }
  });
  z$ = d3.select('#wedges').selectAll('.wedges').data(vertices);
  z$.exit().remove();
  z1$ = z$.enter().append('g');
  z1$.attr('class', 'wedges');
  w = z$.selectAll('.wedge').data(function(it){
    var p, i$, ref$, len$, edge, j$, ref1$, len1$, player;
    p = [];
    for (i$ = 0, len$ = (ref$ = it.edges).length; i$ < len$; ++i$) {
      edge = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = users[edge] || 0).length; j$ < len1$; ++j$) {
        player = ref1$[j$];
        p.push({
          player: player,
          edge: edge
        });
      }
    }
    return p;
  });
  z2$ = w;
  z2$.exit().remove();
  z2$.enter().append('path');
  z2$.attr('class', function(it){
    return "wedge player-" + it.player;
  });
  z2$.attr('d', function(arg$, i, vertexId){
    var player, edge, vertex, cx, cy, r, line, angle, offsetStart, offsetEnd, x2, y2, sign, dSign, osx, osy, oex, oey, dx, dy, dr, D, t, term, sgn, isx, isy, iex, iey, ddx, ddy;
    player = arg$.player, edge = arg$.edge;
    vertex = vertices[vertexId];
    cx = x(vertex.x);
    cy = y(vertex.y);
    r = 2 * d3.max(vertex.edges, function(it){
      return it.bandwidth;
    });
    line = allocLine(state, users, player, edge);
    angle = line.angle, offsetStart = line.offsetStart, offsetEnd = line.offsetEnd;
    offsetStart -= edge.bandwidth / 2;
    offsetEnd -= edge.bandwidth / 2;
    offsetStart *= 4;
    offsetEnd *= 4;
    if (vertex === edge[0]) {
      x2 = x(edge[1].x);
      y2 = y(edge[1].y);
      sign = dSign = 1;
    } else {
      x2 = x(edge[0].x);
      y2 = y(edge[0].y);
      sign = dSign = -1;
    }
    osx = offsetStart * Math.sin(angle);
    osy = offsetStart * Math.cos(angle);
    oex = offsetEnd * Math.sin(angle);
    oey = offsetEnd * Math.cos(angle);
    dx = x2 - cx;
    dy = y2 - cy;
    dr = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    D = osx * (dy + osy) - (dx + osx) * osy;
    t = Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2);
    if (t < 0) {
      t = 0;
    }
    term = Math.sqrt(t);
    sgn = function(it){
      if (it < 0) {
        return -1;
      } else {
        return 1;
      }
    };
    sign *= angle > 0 ? -1 : 1;
    isx = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    isy = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    D = oex * (dy + oey) - (dx + oex) * oey;
    term = Math.sqrt(Math.pow(r, 2) * Math.pow(dr, 2) - Math.pow(D, 2));
    iex = (D * dy + sign * sgn(dy) * dx * term) / Math.pow(dr, 2);
    iey = (-D * dx + sign * Math.abs(dy) * term) / Math.pow(dr, 2);
    ddx = iex - isx;
    ddy = iey - isy;
    return "M " + cx + " " + cy + " l " + isx + " " + isy + " a " + r + " " + r + " 0 0 " + (dSign > 0 ? 1 : 0) + " " + ddx + " " + ddy + " Z";
  });
  z3$ = d3.select('#players').selectAll('.player').data(players);
  z3$.exit().remove();
  z4$ = z3$.enter().append('g');
  z4$.attr('class', 'player');
  z4$.attr('id', function(it){
    return "player-" + it;
  });
  z4$.append('g').attr('class', 'path');
  z3$.select('.path').each(function(player){
    var s, line, x$;
    s = state.strategies[player];
    line = s.path.map(allocLine(state, users, player));
    x$ = d3.select(this).selectAll('.segment').data(line);
    x$.exit().remove();
    x$.enter().append('line').attr('class', 'segment');
    x$.attr({
      x1: function(it){
        return it.x1;
      },
      y1: function(it){
        return it.y1;
      },
      x2: function(it){
        return it.x2;
      },
      y2: function(it){
        return it.y2;
      },
      'stroke-width': s.bandwidth * 4
    }).classed('bottleneck', function(it){
      return it.bottleneck;
    });
    return x$;
  });
};
draw();
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}